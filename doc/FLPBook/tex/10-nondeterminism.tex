%!TEX root = main.tex
\Lesson{Неоднозначные вычисления и монады}

\section{Неоднозначные вычисления}\index{вычисления!детерминистические}%
Привычный подход к программированию подразумевает, что всякая величина (переменная, аргумент или значение функции) в каждый момент времени выполнения программы может иметь единственное значение. Если же возникает необходимость перебрать несколько вариантов значений, организуется явный цикл.
Однако, при формулировке и решении ряда задач полезно мыслить иначе. Можно <<разрешить>> константам и аргументам функций иметь множество значений <<одновременно>>, при этом функции тоже должны иметь возможность возвращать множество результатов. Такие величины и функции называются \emph{неоднозначными}.

Для того, чтобы отличать неоднозначные величины от обычных, введём абстрактный тип \Type{Amb} (от~английского \emph{ambiguous}):
\begin{SchemeCode}
(define-type Amb)
\end{SchemeCode}
Таким образом, выражения
\begin{SchemeCode}
(define x (Amb 1 2 3))
(define y (Amb 42))
\end{SchemeCode}
будем интерпретировать так: величина \s{x} может быть равна $1$, $2$ или~$3$, в то время как \s{y} принимает одно единственное значение~$42$. Особый смысл имеет выражение \s{(Amb)}. Оно означает как отсутствие вариантов, так и <<невозможное>> значение, логическое противоречие.

Неоднозначные функции могут с помощью \s{Amb} возвращать множество возможных значений. Например, для действительных $x$ и $y$, если $y^2 = x$, то $y = \pm\sqrt{x}$, а если $x<0$, то решения не существует. Таким образом, вещественный квадратный корень можно представить как неоднозначную функцию:
\label{real-sqrt}%
\begin{SchemeCode}
(:: real-sqrt (Real -> Amb?)
  (define (real-sqrt x)
    (if ($\ge$ x 0) 
        (let ([y (sqrt x)]) (Amb y (- y)))
        (Amb))))
\end{SchemeCode}
\REPL{(real-sqrt 4)}{(Amb -2 2)}
\REPL{(real-sqrt 0)}{(Amb 0)}
\REPL{(real-sqrt -4)}{(Amb)}
Здесь \s{(Amb)} отражает невозможность вычисления вещественного квадратного корня для отрицательного аргумента.

\section[4]{Комбинирование недетерминистических~вычислений}%
Рассмотрим теперь, каким образом следует вычислять неоднозначные функции от неоднозначных аргументов. Пусть, например, величина $x$ может быть равна \mbox{$0$, $1$ или $16$}, чему может быть равен квадратный корень из $x$? Ответ в этом случае такой: $0, 1, -1, 4$ или $-4$. То есть, решением будет объединение всех возможных значений функции для всех возможных значений аргументов.

Введём функцию \fun{amb-apply}{x f}, обобщающую понятие аппликации для неоднозначных функций. Она вычисляет значения функции \lex{f} для всех возможных значений \lex{x}, объединяя результаты с помощью функции \s{amb-plus}:
\begin{Definition}[emph={x,f}]
(:: amb-apply ((Any -> Amb?) Amb? -> Amb?)
  (define/. amb-apply
    f (Amb x ___) --> (foldr ($\circ$ amb-plus f) (Amb) x)))%\medskip%
(:: amb-plus (Amb? Amb? -> Amb?)
  (define/. amb-plus
    (Amb x ___) (Amb y ___) --> (apply Amb (append x y))))
\end{Definition}

\newpage\noindent
Теперь мы можем вычислить корень от неоднозначной \mbox{величины:}\smallskip
\REPL{(amb-apply real-sqrt (Amb 0 1 16))}
     {(Amb 0 -1 1 -4 4)}
\noindent А самое главное --- мы получили возможность комбинировать неоднозначные функции. Применим \s{real-sqrt} повторно:
\begin{SchemeCode}
  > (amb-apply real-sqrt 
               (amb-apply real-sqrt (Amb 0 1 16)))
\end{SchemeCode}\vspace{-\smallskipamount}
\REPLout{(Amb 0 -1 1 -2 2)}
Обратите внимание на то, что наличие отрицательных чисел среди вариантов аргумента функции \s{real-sqrt} не~привело к~ошибке, поскольку, согласно нашему определению, для таких аргументов решения просто не~существует.

\section{<<Синтаксический сахар>>}%
Функция \s{real-sqrt} была разработана так, чтобы возвращать несколько значений. Однако, существует способ превратить любую функцию в неоднозначную. 

Для унарной функции достаточно <<втянуть>> её результат в неоднозначные вычисления конструктором \s{Amb}. Так, например, вычисляется квадрат от неоднозначной величины:
\begin{SchemeCode}
   > (amb-apply ($\circ$ Amb sqr) (Amb 1 2 3))
\end{SchemeCode}\vspace{-\medskipamount}
\REPLout{(Amb 1 4 9)}

В случае функций большей валентности всё не так просто. Вот, как можно вычислить значения суммы двух неоднозначных величин \s{(Amb 10 20)} и \s{(Amb 3 4 5)}:
\begin{SchemeCode}[emph={x,y}]
   > (amb-apply 
      (lambda (x) 
        (amb-apply 
         (lambda (y) 
           (Amb (+ x y))) 
         (Amb 3 4 5)))
      (Amb 10 20) )
\end{SchemeCode}\vspace{-\medskipamount}
\REPLout{(Amb 13 14 15 23 24 25)}
\noindentНо такая запись очень неудобна и не отражает сути вычислений. Определим функцию \s{amb-bind}, отличающуюся от \s{amb-apply} порядком аргументов:
\newpage
\begin{Definition}
(:: amb-bind (Amb? (Any -> Amb?) -> Amb?)
  (define amb-bind (flipped amb-apply)))
\end{Definition}
Она <<направляет>> неоднозначную величину в функцию или, как говорят, связывает их. С помощью \s{amb-bind} вычисление суммы двух неоднозначных величин записывается в виде последовательности связываний:
\begin{SchemeCode}[emph={x,y}]
  > (amb-bind 
     (Amb 10 20) (lambda (x) 
                   (amb-bind 
                     (Amb 3 4 5) (lambda (y) 
                                   (Amb (+ x y))))))
\end{SchemeCode}\vspace{-\medskipamount}
\REPLout{(Amb 13 14 15 23 24 25)}
Теперь видно, что \lmфункции связывают с символами \lex{x} и \lex{y} их возможные значения и далее передают их функции \s{+}. Приведённая здесь цепочка вычислений соответствует \emph{стилю передачи продолжений} (CPS~--- continuation passing style). При этом строго задаётся последовательность вычислений, и каждая из вложенных \lmфункций содержит в себе информацию об оставшихся вычислениях. Такие функции называются \emph{продолжениями}.

Очевидно, что показанный нами способ вычислений универсален (на месте функций  \s{sqrt} и \s{+} могли оказаться любые другие функции), но всё равно, он неудобен и громоздок. В таких случаях имеет смысл прибегнуть к помощи макропрограммирования и создать подходящую специальную форму, т.\,н. <<синтаксический сахар>>.

Определим форму \s{do}, абстрагирующую связывание недетерминистических величин и произвольных функций:

\sfindex{do}
\begin{Definition}[emph={x,A,res,B}]
(define-syntax do
  (syntax-rules (<-) 
    [(do (x <- A) res) (amb-bind A (lambda (x) res))]
    [(do A B ___ res)  (do A (do B ___ res))]))
\end{Definition}

Здесь мы используем несколько более сложные приёмы макропрограммирования, чем прежде. Это связано с тем, что определяемая нами форма раскрывается рекурсивно, а поэтому требует рассмотрения нескольких вариантов. 

Разберёмся, как устроен этот макрос. Для представления синтаксических вариантов используется форма \sfi{syntax-rules}, в ней с помощью образцов описывается возможный синтаксис. Первый параметр этой формы \s{(<-)} указывает, что символ \s{<-} не требует определения и является ключевым (как, например, символ \s{else} в форме \s{cond}).
Третья строчка предписывает \emph{переписать} выражение вида \s{(do (x <- A) res)} в соответствующее выражение, использующее \s{amb-bind}. Последняя строка показывает, как следует переписывать последовательность операторов в форме \s{do} (образец последовательности {\schemestyle B ...} должен указываться не только в левой, но и в правой части макроса).

Вот как записывается вычисление суммы неоднозначных величин с помощью формы \s{do}:
\begin{SchemeCode}
(do (x <- (Amb 10 20))
    (y <- (Amb 3 4 5)) 
    (Amb (+ x y)))
\end{SchemeCode}

Эту запись можно толковать так: с помощью оператора \s{<-} мы <<извлекаем>> по одному варианты из входных данных, именуем их, а~в~конце --- комбинируем с помощью той или иной функции и~<<возвращаем>> результат обратно в коллекцию вариантов, используя конструктор \s{Amb}.

\section[2]{Охраняющие условия}%
В примере с функцией \s{real-sqrt} нам с помощью выражения \s{(Amb)} удалось исключить из рассмотрения отрицательные числа при вычислении квадратного корня. Условие в определении функции \s{real-sqrt} одновременно служит охраной от возникновения исключительной ситуации и обеспечивает отбрасывание нежелательных вариантов из возможных возвращаемых значений.

Абстракцией такой охраны будет служить функция \fun{guard}{p}:

\begin{Definition}[emph={p}]
(:: guard (Any -> Amb?)
  (define (guard p)
    (if p (Amb null) (Amb))))
\end{Definition}

Она устроена следующим образом. В случае невыполнения охраняющего условия \lex{p}, она возвращает  выражение \s{(Amb)}~--- признак <<неудачи>>. Если же охраняющее условие выполняется, возвращается, вообще говоря, произвольное значение, в нашем случае~--- символ \s{null}, хотя на его месте могло быть всё, что угодно.

Каким же образом можно использовать эту странную функцию? Посмотрите на следующее выражение, записанное в CPS:

\begin{SchemeCode}[emph={x,y,z}]
(amb-bind (Amb 1 2 3) 
          (lambda (x) 
            (amb-bind (guard (odd? x))
                      (lambda (z) 
                        (amb-bind (Amb 10 20 30)
                                  (lambda (y) (Amb (+ x y))))))))
\end{SchemeCode}

Сначала первое значение из \s{(Amb 1 2 3)} будет связано с символом $x$. В этом случае выполнится охраняющее условие и функция \s{guard} вернёт выражение \s{(Amb null)}. Символ \lex{z} будет связан со значением \s{null} и вычисления продолжатся, но, так как символ \lex{z} нигде в дальнейших вычислениях не используется, это никак не отразится на их результате.  Теперь понятно, почему совершенно неважно, что именно возвращает функция \s{guard} в случае успеха, однако, необходимо, чтобы возвращаемая величина могла быть связана с помощью \s{amb-bind}, и для этого она <<обёрнута>> конструктором~\s{Amb}.

После того, как будут обработаны все варианты для величины~\lex{y}, вычисления обратятся к следующему значению \lex{x}. В этом случае \s{guard} вернёт \s{(Amb)}, никакого связывания с \lex{z} вообще не произойдёт: выражение \s{(amb-bind (Amb) (lambda (z) ...))} немедленно вернёт \s{(Amb)}, продолжение \s{(lambda (z) ...)} ни разу не будет выполнено, а значит, не будет и перебора вариантов для \lex{y}. Полученное значение \s{(Amb)} будет отброшено и вычислительный процесс перейдёт к очередному значению \lex{x}.

Таким образом, охраняющая функция \s{guard} не просто исключает нежелательные варианты из всех возможных значений ответа, но и избавляет от ненужных вычислений, отбрасывая соответствующие им продолжения. В рассмотренном нами примере, вместо девяти вычислений суммы, будет произведено только шесть~--- это столько, сколько существует решений для заданного ограничения.

Сделаем так, чтобы функцию \s{guard} можно было включать в форму \s{do}:

\begin{Definition}[emph={x,A,res,B}]
(define-syntax do
  (syntax-rules (<-) 
    [(do (x <- A) res) (amb-bind A (lambda (x) res))]
    [(do A res)        (amb-bind A (lambda (_) res))]
    [(do A B ___ res)  (do A (do B ___ res))]))
\end{Definition}

Добавленная строчка показывает, каким образом обрабатываются операторы, которые возвращают не используемые в дальнейшем значения. Здесь символ \s{_} играет роль произвольной переменной.

Вот как записывается с использованием формы \s{do} разобранный нами пример:

\begin{SchemeCode}
(do (x <- (Amb 1 2 3))
    (guard (odd? x))
    (z <- (Amb 10 20 30))
    (Amb (+ x z)))
\end{SchemeCode}


\section[2]{Понятие монады}%
Подведём итог. Для реализации неоднозначных вычислений нам понадобилось определить абстрактный тип для представления неоднозначных величин \s{Amb}, а также операции связывания \s{amb-bind} и объединения \s{amb-plus}. Кроме того, для удобства записи программ, мы ввели форму \s{do} и охраняющий оператор \s{guard}.

Обратите внимание на то, как изменилась формулировка приводимых нами решений: она стала напоминать \emph{описание последовательности действий}. 
Например, в последнем примере мы сначала <<присваиваем>> символу \lex{x} какие-то значения, затем проверяем их на нечётность, затем <<присваиваем>> символу \lex{z} свои значения и, наконец, возвращаем возможные значения функции. Выходит, к концу курса функционального программирования мы  пришли к <<императивной>> программе? 

На самом деле, мы получили нечто гораздо большее, чем эмуляция императивного стиля программирования. Нам удалось задать \emph{семантику} последовательных вычислений, то есть, определить что означают слова <<затем>>, <<присвоить>> и <<вернуть>>. Это значит, что мы построили абстракцию для таких чрезвычайно важных операций, как  аппликация функции, связывание величины с переменной и управление вычислительным потоком. В наших руках оказался мощный инструмент, представляющий собой \index{абстракция!последовательных вычислений}\emph{абстракцию последовательных вычислений}, который называется \emph{монадой}. 

\index{монада}Монада --- это совокупность трёх объектов:
\begin{enumerate}
  \item абстрактного типа \Type{m},
  \item единичной функции 
  \begin{center}
  \Type{\s{return ::} A -> (m A)},
  \end{center}
  \item и функции связывания 
  \begin{center}
  \Type{\s{bind ::} (m A) (A -> (m B)) -> (m B)},
  \end{center}
\end{enumerate}
для которых должны выполняться следующие соотношения:
\begin{SchemeCode}[emph={f,x,y,g}]
  (bind (return x) f) = (f x);
  (bind x return) = x;
  (bind (bind x f) g) = (bind x (lambda (y) (bind (f y) g))).
\end{SchemeCode}
Первые два соотношения показывают, что единичная функция является нейтральной для операции связывания, а последнее~--- как организуется цепочка связываний.

Кроме того, для некоторых монад можно определить <<нулевой>> элемент \s{mzero}, такой что:

\begin{SchemeCode}[emph={f,x,y}]
  (bind mzero f) = (bind x (lambda (y) mzero)) = mzero
\end{SchemeCode}
\noindentи операцию сложения \s{mplus}, для которой \s{mzero} является нейтральным элементом, то есть,
\begin{SchemeCode}
  (mplus mzero x) = (mplus x mzero) = x
\end{SchemeCode}

Наконец, для любой монады с нулевым элементом существует охраняющая функция:

\begin{SchemeCode}[emph={p}]
  (guard p) = (if p (return null) mzero)
\end{SchemeCode}

Язык \Scheme предоставляет богатый инструментарий для определения и использования монад (см. справочное руководство по \Scheme). Вот как можно было бы определить монаду для неоднозначных вычислений:
\begin{SchemeCode}
(define-monad Amb-monad
  #:type Amb?
  #:return Amb
  #:bind amb-bind
  #:mplus amb-plus
  #:mzero (Amb))
\end{SchemeCode}

\section[2]{Использование монад}%
Что же позволяют делать монады? Во-первых, они являются абстракцией вычислительного процесса и, в этом смысле, позволяют определять различные парадигмы программирования. 

Во-вторых, любая монада позволяет использовать так называемую do-нотацию (в нашем случае, ей соответствует форма \s{do}), которая является абстракцией последовательности операторов связывания и управления потоком вычислений с семантикой, задаваемой монадой. Кроме того, существует множество универсальных монадических функций, таких, как монадические свёртка и фильтрация, поднятие функций в монаду и т.п., которые определены и могут быть использованы для любых монад.

Наличие универсального синтаксиса и набора функций для работы с монадами позволяет менять семантику программы, не меняя её кода.

Давайте убедимся в этом. Перепишем определение функции \s{real-sqrt}, используя универсальные монадические операторы:
\begin{SchemeCode}
(define (real-sqrt x)
  (do (guard ($\ge$ x 0))
      [y <- (return (sqrt x))]
      (return y (-y))))
\end{SchemeCode}

Определим монаду, рассматривающую не все возможные варианты неоднозначных величин, а только первый успешный. Она называется \s{Maybe} и используется в тех случаях, когда однозначные вычисления могут завершиться неудачей.
\begin{SchemeCode}
(define-type (Just Any))
(define-type Maybe? Just? 'Nothing)

(define-monad Maybe
  #:type Maybe?
  #:return (lambda (x . y) (Just x))
  #:bind   (/. (Just x) f --> (f x)
               'Nothing f --> 'Nothing)
  #:mplus  (/. 'Nothing x --> x
               x 'Nothing --> x
               x _ --> x)
  #:mzero  'Nothing)
\end{SchemeCode}

\noindent
Теперь вычислим корень из $4$ и $-4$ в разных монадах:
\REPL{(using Amb-monad (real-sqrt 4))}{(Amb 2 -2)}
\REPL{(using Amb-monad (real-sqrt -4))}{(Amb)}
\REPL{(using Maybe (real-sqrt 4))}{(Just 2)}
\REPL{(using Maybe (real-sqrt -4))}{Nothing}

В функциональном программировании используется множество различных монад. С их помощью в рамках чистого ФП реализуются такие фундаментальные концепции, как последовательность вычислений и побочные эффекты (ввод-вывод, отладка, обработка исключений и т.п.), продолжения, объекты с изменяемым состоянием и объекты с общим доступом, оперирование коллекциями: списками, множествами, распределениями вероятностей и т.п.

\newpage
\begin{Assignment}
a) Используя функции для работы с множествами (см. \Asref{as:set}), определите монаду \s{Set}, подобную монаде \s{Amb-monad}, но оперирующую, вместо списков, множествами возможных значений. 

б) Измените определение монады \s{Amb-monad} так, чтобы перебор и объединение вариантов стали ленивыми.
\end{Assignment}

\section[2]{Монада List}%
Все дальнейшие примеры в этой главе будут приводиться для монады \s{List} с использованием форм и монадических функций, определённых в языке \Scheme. Монада \s{List} реализует неоднозначные вычисления, но использует для представления вариантов значений обыкновенные списки. Ниже даётся её определение  

\begin{SchemeCode}
(define-monad List
  #:type list?
  #:return list
  #:bind (lambda (x f) (foldr ($\circ$ mplus f) mzero x))
  #:mplus append
  #:mzero '())
\end{SchemeCode}

Как видно, построенная нами монада \s{Amb-monad} функционально эквивалентна монаде \s{List}.

\section{Генерация последовательностей}%
Рассмотрим задачу получения множества величин с заданными свойствами. Допустим, нам необходимо получить множество квадратов чётных чисел, не превышающих $N$.  Вот как принято записывать определение для такого множества в математике:  $$\left\{ x^2~|~x \in {1, 2, ..., N};~~ x~mod~2 = 0 \right\}$$

Такой способ описания списков, множеств или последовательностей, называется \emph{генерацией} (\emph{list comprehension}) и используется во многих функциональных языках. Генераторы множеств чрезвычайно полезны, поэтому для них определена специальная форма \sfi{collect}.
Вот как выглядит генератор для определённого выше множества:
\begin{SchemeCode}[emph={x,N}]
  (collect (sqr x) [x <- (range 1 N)] (even? x))
\end{SchemeCode}
\noindent
На самом деле, это --- просто сокращённая запись для следующего выражения:
\begin{SchemeCode}[emph={x,N}]
  (do [x <- (range 1 N)]
      (guard (even? x))
      (return (sqr x)))
\end{SchemeCode}

\begin{Assignment}
Определите множество так называемых пифагоровых троек (египетских треугольников):
$$T = \left\{ [a~b~c]~|~a,b,c \in Z; a^2 + b^2 = c^2 \right\}$$
Описав это множество,
\begin{itemize}
  \item получите множество почти равнобедренных пифагоровых треугольников (таких, у которых длины двух сторон отличаются на единицу);
  \item получите множество примитивных пифагоровых треугольников, у которых все стороны взаимно просты;
  \item получите множество пар пифагоровых треугольников с одинаковой а) площадью, б) периметром, в) стороной.
\end{itemize}
\end{Assignment}


\section{Недетерминисти\-чес\-кие~программы}%
Инструментарий, который мы создали, позволяет писать программы без явного указания того, \emph{как} производятся вычисления. Программа содержит только лишь информацию о \emph{возможных} значениях входящих в неё величин, соотношения между этими величинами, а так же ограничения, определяющие цель --- решение задачи. При этом, на этапе написания программы неизвестно, какие именно значения из множества возможных, приведут к решению задачи. Такой подход называется \emph{недетерминистическим}.\index{вычисления!недетерминистические}

Решение недетерминистической задачи заключается в систематическом поиске всех вариантов, не приводящих к противоречию. Рассмотренный нами выше алгоритм перебора вариантов с охраной, исключающий часть вычислений, называется \emph{методом поиска в глубину с возвратом} (backtracking). Он позволяет существенно повысить эффективность алгоритмов систематического поиска.

Недетерминистическое программирование имеет широкое применение в самых разнообразных областях: в математике, при обработке текстов, в экспертных системах, в системах искусственного интеллекта и т.п. В качестве примеров и заданий мы рассмотрим задачи, которые принято относить к логическим и математическим головоломкам, чтобы с их помощью показать изящество и лаконичность недетерминистического подхода.

Рассмотрим следующую задачу. Имеется четыре списка слов:

\begin{itemize}
  \item \s{("the" "that" "a")}
  \item \s{("frog" "elephant" "thing" "turtle")}
  \item \s{("walked" "eats" "treaded" "grows")}
  \item \s{("slowly" "quickly" "salad")}
\end{itemize}

Необходимо найти, какие фразы можно составить, используя ровно по одному слову из всех этих списков, при двух условиях: 1) слова должны следовать в том же порядке, в котором указаны списки и 2) в каждой последовательной паре слов последняя буква первого слова должна совпадать с первой буквой второго. Например пара \s{"the"} и \s{"elephant"} удовлетворяют этому условию, а пара \s{"the"} и \s{"frog"} --- нет. 

Определим предикат \fun{joined?}{a b}, который определяет, связаны ли, согласно условию задачи, слова \lex{a} и \lex{b}:
\begin{SchemeCode}[emph={a,b}]
(define (joined? a b)
  (equal? (last (string->list a)) 
          (first (string->list b))))
\end{SchemeCode}

А теперь запишем условие задачи в терминах недетерминистических вычислений:

\begin{SchemeCode}[emph={w1,w2,w3,w4}]
> (collect (list w1 w2 w3 w4)
    (w1 <- '("the" "that" "a"))
    (w2 <- '("frog" "elephant" "thing" "turtle"))
    (joined? w1 w2)
    (w3 <- '("walked" "eats" "treaded" "grows"))
    (joined? w2 w3)
    (w4 <- '("slowly" "quickly" "salad"))
    (joined? w3 w4))%\smallskip%
'%\outputstyle(("that"\ "thing"\ "grows"\ "slowly")%
  %\outputstyle("that"\ "thing"\ "grows"\ "salad")%
  %\outputstyle("that"\ "turtle"\ "eats"\ "slowly")%
  %\outputstyle("that"\ "turtle"\ "eats"\ "salad"))% 
\end{SchemeCode}

Обратите внимание на то, как расположены ограничения. Первое условие \s[emph={w1,w2}]{(joined? w1 w2)} исключит перебор вариантов, не удовлетворяющих заданному условию. Таким образом, например, для слов \s{"the"} и \s{"frog"} третье слово подбираться не будет. Если бы мы сгруппировали охраняющие выражения по-другому, скажем, поместили бы их после определения списков слов, ответ был бы точно таким же, изменилась бы только эффективность решения: потребовалось бы рассмотреть $3\times4\times4\times3=144$ варианта. Приведённая в примере программа находит решение, перебирая только $3\times4+3\times4+3\times3=33$ варианта.

Это любопытное замечание: порядок следования операторов корректной логической программы, как правило, не влияет на ответ; от порядка зависит только её эффективность.

Рассмотрим ещё одну классическую задачу. Фермер купил 100~голов скота на 100~долларов. Сколько каких животных он купил, если корова стоит 12~долларов, свинья --- 4~доллара, а овца --- 50~центов?

Приведём недетерминистическую программу, решающую эту задачу методом перебора:

\begin{SchemeCode}[emph={c,p,s}]
   > (collect `((,c cows) (,p pigs) (,s sheeps))
      [c <- (range 1 100/12)]
      [p <- (range 1 100/4)]
      [s <- (return (- 100 c p))]
      (= 100 (+ (* c 12) (* p 4) (* s 0.5))))
\end{SchemeCode}
\REPLout{(Amb ((1 cows) (11 pigs) (88 sheeps)))}

Здесь мы воспользовались тем, что недетерминистические величины представляются списками, таким образом, список натуральных чисел, возвращаемый функцией \s{range} годится в качестве множества возможных вариантов.

Эта задача, на первый взгляд, кажется чересчур простой для того, чтобы решать её методом перебора. Однако её аналитическое решение сводится к решению диофантового уравнения, и~оно вовсе не~тривиально. К~тому же, решений может быть несколько (например, если бы корова стоила 8~долларов, существовало бы шесть способов решить задачу, в~то время, как для цены в~11~долларов решений не~существует).

\newpage
\begin{Assignment}
Решите следующие задачи:

\medskip
а) Пять школьниц написали экзаменационную работу и все получили разные оценки. Они решили, что каждая девочка должна сообщить домой о результатах экзамена и при этом сделать одно верное и
одно неверное утверждение. Вот соответствующие выдержки из их писем:
\begin{itemize}
  \item Бетти: «Китти была на экзамене второй, а я только третьей».
  \item Этель: «Вам будет приятно узнать, что я написала лучше всех. Второй была Джоан».
  \item Джоан: «Я была третьей, а бедная Этель последней».
  \item Китти: «Я оказалась второй. Мэри была только четвертой».
  \item Мэри: «Я была четвертой. Первое место заняла Бетти».
\end{itemize}
 В каком порядке на самом деле расположились отметки девочек?
 
 \medskip
 б)\label{as:rectangles} Какие стороны должен иметь прямоугольник, сложенный на плоскости из одинаковых квадратов так, чтобы число квадратов, оказавшихся на его границе было равно числу внутренних квадратов? Решите эту же задачу для трёх измерений.

  \medskip
 в) Задача <<Сплетники>>: $A$ говорит, что $B$ отрицает, что $C$ считает, что $A$ всегда врёт, но, в свою очередь, $B$ рассказывает всем, что $A$ не склонен верить $C$. При этом $C$ уверяет, что слышал, как $A$ говорил о том, что $B$ считает $C$ лжецом. Выясните, кто из них всегда говорит правду, а кто всегда врёт.
 
 Для выражения отношения <<$x$ сказал, что $y$>>, используйте бинарный предикат \fun{says}{x y}, который возвращает истину, только тогда, когда $x$ и $y$ совпадают.
\end{Assignment}


\section{Элементы логического программирования}%
Логическими называют программы, представляющие собой набор утверждений или отношений между элементами перечислимых множеств. С помощью таких программ решаются задачи логического вывода информации на основе заданных фактов и правил вывода.
Приведём ряд простых примеров логических программ.

Функция \s{palindrom} определяет, является ли список палиндромным (одинаково читающимся как справа налево, так и в обратном порядке)

\begin{SchemeCode}[emph={x,y}]
(define palindrom?
  (/. '() --> #t
      `(,x) --> #t
      `(,x ,y ___ ,x) --> (palindrom? y)
      _ --> #f))
\end{SchemeCode}

Определяя эту функцию, мы просто перечислили, в каких случаях список можно считать палиндромным: если он пуст или содержит единственный элемент, а так же, если его первый и последний элементы совпадают, а средняя часть является палиндромной. Во всех прочих случаях, согласно последней строчке определения, список палиндромным не является.

Ещё один пример: функция \fun{distinct}{x y ...} определяющая все ли её аргументы различны:

\begin{SchemeCode}
(define distinct
  (/. x x _ ___ --> #f
      x y z ___ --> (and (apply distinct x z)
                         (apply distinct y z))))
\end{SchemeCode}

Первая строчка гласит, что, если первые два аргумента совпадают, то предикат возвращает \s{#f}. Вторая~--- что аргументы различны, если все они различны попарно.

Характерной особенностью логических программ является то, что все определяемые функции являются предикатами. Но это не означает, что такие программы позволяют получать только ответы <<да>> или <<нет>>. Пользуясь предикатами, как утверждениями, можно выводить новые отношения и получать информацию с помощью дедуктивного метода.

Рассмотрим следующий набор утверждений, касающий некоторой семьи:
Эндрю и Анна являются родителями Боба и Билла. Боб, в свою очередь, женившись на Бесси, родил Джесси и Джеймса. Вот как можно описать эти отношения:

\begin{Definition}
(define family '(Ann Andrew Bob Bill Bessy Jessy James))

(define mother
  (/. 'Ann 'Bob --> #t
      'Ann 'Bill --> #t
      'Bessy 'Jessy --> #t
      'Bessy 'James --> #t
      _ _ --> #f))

(define father
  (/. 'Andrew 'Bob --> #t
      'Andrew 'Bill --> #t
      'Bob 'Jessy --> #t
      'Bob 'James --> #t
      _ _ --> #f))
\end{Definition}
Эти предикаты можно рассматривать, как базу данных. Как мы можем извлечь информацию из этой базы? Можно задавать простые вопросы:
\REPL{(mother 'Ann 'Bob)}{#t}
\REPL{(mother 'Ann 'Chester)}{#f}
Но это не столь уж полезное применение. Попробуем выяснить, кто является матерью Джесси:

\REPL{(collect x [x <- family] (mother x 'Jessy))}
     {(Bessy)}

А кому является отцом Эндрю?
\REPL{(collect x [x <- family] (father 'Andrew x))}
     {(Bob Bill)}

Видно, что мы можем получать ответы на запросы к нашей базе. Оформим для удобства запрос в виде макроса:
  
\sfindex{?}
\begin{Definition}[emph={p,x,set}]
(define-syntax ?
  (syntax-rules (<-)
    [(? [x <- set] p) (collect x [x <- set] p)]
    [(? [x <- set] ___ p) (collect (list x ___)
                            [x <- set] ___ p)]))
\end{Definition}

Теперь можно обращаться к нашей базе таким образом:
\REPL{(? [x <- family] (mother x 'Jessy))}{(Bessy)}
\REPL{(? [x <- family] (father 'Andrew x))}{(Bob Bill)}
\REPL{(? [x <- family] [y <- family] (father x y))}
{((Andrew Bob) (Andrew Bill) (Bob Jessy) (Bob James))}

Характерно, что запросы работают симметрично. Мы можем выяснять, кто чей сын и кто чей отец, располагая одной и той же формой.

Определим теперь отношение <<родитель>> следующим образом:
\begin{Definition}[emph={x,y}]
(define parent (orf mother father))
\end{Definition}
Теперь можно выяснить, кто является родителями Джесси:
\REPL{(? [x <- family] (parent x 'Jessy))}{(Bob Bessy)}

Следующим шагом будет определение отношения <<прародитель>>. Сформулируем его так: $x$ является прародителем $y$, если существует~$z$, такой что $x$~--- родитель $z$, и~$z$ --- родитель $y$. 

Для этого нам необходимо ввести квантор существования. Оформим его в виде макроса\footnote{Символ $\exists$ можно ввести в \Lang{DrRacket} следующим образом: набрать \s{\\exists} а потом нажать \MenuItem{Alt} + \s{\\}.}:

\sfindex{exists@$\exists$}
\begin{Definition}[emph={x,set,p}]
(define-syntax-rule ($\exists$ [x <- set] ___ p)
  (not (empty? (? [x <- set] ___ p)))) 
\end{Definition}

С его помощью запишем предикат для прародителя:
\begin{Definition}[emph={x,y,z}]
(define (grand-parent x y)
  ($\exists$ [z <- family] (and (parent x z) (parent z y))))
\end{Definition}
\REPL{(? [x <- family] (grand-parent 'Ann x))}{(Jessy James)}
\REPL{(? [x <- family] (grand-parent x 'James))}{(Ann Andrew)}

Наконец, укажем кого можно считать предком:
\begin{Definition}[emph={x,y,z}]
(define (ancestor x y) 
  (or (parent x y)
      ($\exists$ [z <- family] (and (parent x z) (ancestor z y)))))  
\end{Definition}

Выясним с его помощью, является ли Эндрю предком Джесси, и кто является потомком Анны:
\REPL{(? [x <- family] (ancestor 'Andrew 'Jessy))}{#t}
\REPL{(? [x <- family] (ancestor 'Ann x))}{(Bob Bill Jessy James)}

\newpage
\begin{Assignment}
а)  Напишите определения для следующих отношений:
\begin{itemize}
  \item жена, муж, супруги;
  \item бабушка, дедушка,  внук;
  \item брат или сестра;
  \item тётя, дядя, племянник.
\end{itemize}

\medskip
б)  Имеется ориентированный граф, в котором вершины соединяются следующим образом: $A\to B$, $A\to C$, $B\to D$, $B\to E$, $D\to C$, $E\to C$. Найдите
\begin{itemize}
\item какие вершины достижимы из вершины $A$,
\item из каких вершин можно попасть в $E$,
\item какие вершины не связаны ни одним путём в графе.
\end{itemize}
\end{Assignment}


\section[2]{Язык \Lang{Prolog}}%
Созданные нами формы и функции позволили реализовать некоторые из основных принципов логического программирования: поиск с возвратом, построение программ, как совокупности отношений, и возможность решения как <<прямых>>, так и <<обратных>> задач (определив отношение <<предок>>, мы смогли с его помощью найти потомков заданного человека). 

Однако? за пределами нашего рассмотрения оказались другие важные механизмы логического программирования, например, унификация или неполные структуры данных. Они в полной мере представлены в таких языках, как \Lang{Prolog} или \Lang{Curry}.


Семантика языка \Lang{Prolog} близка к построенной нами модели недетерминистических вычислений, однако его синтаксис лучше приспособлен к особенностям логического программирования. Вот, например, как на языке \Lang{Datalog} (диалекте \Lang{Prolog}, входящем в \Lang{DrRacket}\footnote{Язык \Lang{Datalog} является языком запросов к базам данных и не в полной мере реализует парадигму логического программирования. Полноценным логическим языком, включённым в \Lang{DrRacket}, является язык \Lang{Racklog} с синтаксисом \Lang{Scheme}.}), формулируются семейные отношения из рассмотренного нами примера:

\newpage
\begin{Definition}
  #lang datalog

  mother(ann, bob).
  mother(ann, bill).
  mother(bessy, jessy).
  mother(bessy, james).

  father(andrew, bob).
  father(andrew, bill).
  father(bob, jessy).
  father(bob, james).

  parent(X, Y) :- mother(X, Y).
  parent(X, Y) :- father(X, Y).

  grandparent(X, Y) :- parent(X, Z), parent(Z, Y).

  ancestor(X, Y) :- parent(X, Y),
  ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
\end{Definition}

Запросы в \Lang{Datalog} оформляются таким образом:

\begin{SchemeCode}
  > mother(ann,A)?
  %\outputstyle mother(ann, bob).%
  %\outputstyle mother(ann, bill).\smallskip%
  > grandparent(X, jessy)?
  %\outputstyle grandparent(ann, jessy).%
  %\outputstyle grandparent(andrew, jessy).%
\end{SchemeCode}


Как видите, при определении отношений нам не приходится добавлять тривиальных утверждений о ложности всех неперечисленных случаев, нет необходимости явно задавать множество возможных значений и использовать квантор существования для вспомогательных переменных. Повторные определения выполняют роль дизъюнктов, а отношения, перечисляемые через запятую, являются конъюнктами. Отношение  \s{$A$ :- $B$} означает, что $A$ является истинным, если $B$ является истинным.

Язык \Lang{Prolog} и его аналоги используется, как альтернатива и расширение \Lang{SQL} при работе с базами данных, для решения прикладных логических задач (составление расписаний, анализ текстов, построение экспертных систем и онтологий и т.п.).

\begin{Queeze}
 \item В чём состоит основное отличие традиционных и недетерминистических вычислений?
 \item В чём состоит принцип хронологического поиска с возвратом?
 \item Что такое монады и для чего они нужны? 
 \item Каким образом организуются логические программы?
\end{Queeze}
