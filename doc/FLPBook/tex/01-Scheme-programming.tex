%!TEX root = main.tex
% revision is done
\Lesson{Программирование на~\Scheme}

\label{Les:Scheme-programming}

\section{Синтаксис языка \Scheme}%
\label{Sec:expressions}%
%
Синтаксис \Lang{Scheme} и его диалектов столь прост и, вместе с~тем, последователен, что часто можно услышать утверждение, что <<в~\Lang{Scheme} нет синтаксиса>>. Конечно же, это преувеличение, но оно отражает главную особенность языков, ведущих свою родословную от~языка \Lisp: всё с~чем имеют дело и~программист и~транслятор~--- это универсальная синтаксическая структура, называемая \index{S-выражение}\emph{S-выражением} или просто \emph{выражением}.{\tolerance=500\par}

Приведём неполное, но практичное описание выражения, которое может быть программой \Scheme\footnote{На Занятии \ref{Less:lists} мы дадим полное формальное описание S-выражения.}:

\begin{itemize}[--]
 \item Любое выражение может быть либо \emph{атомом}, либо \emph{списком}. 
 \item \index{атом}Атомы могут быть \emph{константами} или \emph{символами}.\footnote{Тут возможна некоторая путаница в терминологии, от того что в русском языке слова «символ» и «знак» часто означают одно и то же: букву или специальный знак алфавита. В английском языке для знаков используется только слово «character», а слово «symbol» имеет более общее значение. В традиции языка \Lisp \emph{символ}~--- это последовательность одного или более \emph{знаков}, играющая роль идентификатора, имени функции или синтаксической конструкции.} 
\begin{itemize}[--]
 \item Константами являются \emph{числа}, \emph{строки} или \emph{булевы} \emph{константы}.
 \item\label{symbol}\index{символ}Символом является любая последовательность знаков латинского, русского или какого-либо ещё алфавитов, а~так же разнообразных знаков, не~включающая в~себя пробела и~служебные знаки: \s{" , ' ` ( ) [ ] #}. 
\end{itemize}
 \item Списки имеют следующий вид \s{(expr ...)}, где \s{expr} --- произвольные выражения. Элементы списка разделяются пробелами.
\end{itemize}

Всё, никаких других синтаксических правил или конструкций для написания программ нам не~понадобится. Если нам и~будут встречаться исключения, то они являются <<синтаксическим сахаром>>, призванным облегчить читаемость программы и~в любом случае, можно обойтись без~них.

Приведём несколько примеров:

\smallskip
\begin{tabular}{>{\comment\raggedright}p{0.3\textwidth}p{0.7\textwidth}}
  Примеры констант: & \parbox{0.7\textwidth}{\s[basicstyle=\constantstyle]{1,  -2.3, 1/3,  1.3e5, \#t, \#f, "abc"}}\\
  Примеры символов: & \parbox{0.7\textwidth}{\s{x,  abc,  =, 1+x,  a->b, zero?}}\\
  Примеры выражений: & \parbox[t]{0.7\textwidth}{\s{1,  x,  (a b),  (+ 1 2),}\\ \s{(f (g a) (g b)),  ((("abc")))}} 
\end{tabular}
\smallskip

Обратите внимание на~то, что, в~отличие от~большинства языков программирования, символы, играющие роль идентификаторов, могут начинаться с~цифр и~включать в~себя разнообразные знаки, не~относящиеся к~алфавиту.

\section{Голова и хвост выражения}%
%
С точки зрения интерпретатора, выра\-жение-список имеет две функционально различные части: \emph{голову}\index{голова выражения} (head) и \emph{хвост}\index{хвост выражения} (tail). Головой является первый элемент выражения, хвостом~--- последовательность остальных элементов. Например, у~выражения \s{(a b c)} головой является символ \s{a}, а~хвостом~--- последовательность символов \s{b}~и~\s{c}.{\tolerance=500\par}

Голова играет роль имени функции, а~хвост~--- последовательности её аргументов. Таким образом, имеется следующее соответствие между математическим обозначением функции и~её записью в~виде выражения \Scheme:
\begin{equation*}
f (x, y,...) \to  \text{\s{(f x y ...)}}
\end{equation*}
\index{нотация!префиксная}Такая форма записи арифметических выражений называется \emph{префиксной скобочной нотацией}.

\section[4]{Простейшие арифметические действия}%
%
Префиксная форма записи последовательно используется для любых выражений \Scheme. Запись арифметических выражений не является исключением и подчиняется общему синтаксическому правилу:
$$
\text{\s{(operator expr1 expr2 ...)}}.
$$
И,~хотя для арифметики такая запись выглядит громоздкой, она не~лишена смысла. Она становится более понятной, если читать её, как выражение <<человеческого>> языка:

\begin{example}{%
<<сумма единицы и двойки>>,

<<разность двойки и тройки>>,

<<произведение трёх и суммы двух, четырёх и четырнадцати>>.}
\begin{ExampleCode}
(+ 1 2)
(- 2 3)
(* 3 (+ 2 4 14))
\end{ExampleCode}
\end{example}

Функции \s{+}, \s{*}, \s{-} и~\s{/} могут принимать любое количество аргументов. При~этом для функций \s{-} и~\s{/} все аргументы, начиная со второго являются, соответственно, вычитаемыми и~делителями. Арифметические выражения со многими аргументами вычисляются следующим образом:

\begin{example}{%
$1+2+3+4$

$1-2-3-4$

$1\times2\times3\times4$

$1/2/3/4 = \frac{1}{2\cdot3\cdot4}$}
\begin{ExampleCode}
(+ 1 2 3 4)
(- 1 2 3 4)
(* 1 2 3 4)
(/ 1 2 3 4)
\end{ExampleCode}
\end{example}

\begin{Assignment}
а) Вычислите следующие выражения в~окне интерпретатора \DrRacket:
$$
\frac{3- 2\cdot(3/2-5^2)}{9\cdot 8\cdot 7\cdot 6\cdot 5},\qquad
2^{3^4},\qquad
\frac{1}{1+\frac{1}{1+1/2}},\qquad
\frac{1}{\sqrt{\pi}}e^{-1,5^2}.
$$

б) Выясните с помощью интерпретатора, как вычисляются такие выражения: \s{+}, \s{(+ 1)}, \s{(+)}, \s{(- 2)}, \s{(-)}, \s{(/ 3)}, \s{(/)}.
\end{Assignment}



\bsfindex{define}
\section{Определения с~помощью define}%
\label{define}Программирование высокого уровня начинается с~возможности давать данным или действиям понятные для человека имена. В~языках программирования базовым инструментом для этого служат присваивания и~определения функций и~процедур. В~языке \Scheme для этого
используются определения, которые \emph{связывают} символы с~их значениями. Это делается с~помощью специальной формы \s{define}.

\begin{example}{%
Дадим определение символу \s{a}. Теперь этот символ связан со~значением 2.}
\REPLin
  {(define a 2)}
\REPL
  {a}
  {2}
\end{example}


\begin{example}{%
Мы можем использовать это определение и~в арифметических действиях, и~в других определениях.}
\REPLin
  {(define b (+ a a))}
\REPL
  {b}
  {4}
\end{example}

Вспомним, как записывается применение функции: \s{(f x y ...)}. Задавая определение для функции, мы синтаксически определяем, что интерпретатор должен сделать, встретив подобную конструкцию.

\begin{example}{%
Таким образом определяется функция \s{sqr}\fnindex{sqr}, возводящая вещественное число в~квадрат.}
\begin{ExampleCode}
> (define (sqr a)
    (* a a))
\end{ExampleCode}
\REPL
  {(sqr 4)}
  {16}
\end{example}

\begin{example}{%
Классический пример: определим вычисление площади круга. Здесь символ \s{pi} обозначает число $\pi$.}
\begin{ExampleCode}
> (define (area r)
    (* pi (sqr r)))
\end{ExampleCode}
\REPL
  {(area 4)}
  {50.26548245743669}
\end{example}

\begin{Assignment}
Напишите определения для функций, вычисляющих среднее арифметическое и~среднее геометрическое двух чисел:

% \index{mean@Scheme@прочие функции}
\begin{Specification}
  (test 
    (mean 1 3)     ==> 2
    (mean 1+i 2-i) ==> 3/2)%\medskip%

  (test 
    (gmean 2 3)     ==> (sqrt (* 2 3))
    (gmean 1+i 1-i) ==> (sqrt 2))
\end{Specification}

\tip{Указание: Прежде чем начинать реализацию функции, скопируйте в~окно определений спецификацию функций. Своё определение пишите перед тестовыми примерами:}%\vspace{-\bigskipamount}
\begin{Specification}

  (define (mean x y)  ...)
  (test 
    (mean 1 3)     ==> 2
    (mean 1+i 2-i) ==> 3/2)
\end{Specification}%\vspace{-\medskipamount}

\tip{Форма \sfi{test} служит для тестирования написанных вами функций. Она принимает последовательность выражений и сравнивает первое со вторым, третье с четвёртым и т.д. Если при выполнении тестов не выводится никаких сообщений об ошибках, значит все сравнения прошли успешно и определённая вами функция соответствует спецификации.}
\end{Assignment}

\section[2]{Условные операторы}\bsfindex{if}%
Для программирования более сложных функций, необходимо иметь возможность производить проверки и выполнять различные действия, в зависимости от результата проверки. 
Простейшее управление потоком вычислений в~\Scheme выполняет специальная форма~\s{if}:
\begin{SchemeCode}
(if test? expr1 expr2)
\end{SchemeCode}

\noindent Её, с~некоторыми оговорками, можно воспринимать, как функцию, возвращающую второй аргумент (\s{expr1}) в~случае выполнения условия \s{test?} и~третий (\s{expr2})~--- в~противном случае.

Условия, используемые в~форме \s{if}, должны возвращать величины булевского типа. В~\Scheme используются следующие символы:
\begin{itemize}[--]
 \item для обозначения истинного значения --- \s{#t},

 \item для обозначения ложного значения --- \s{#f}.
\end{itemize}

Кроме того, в~\Scheme любое значение, кроме ложного, считается истинным:

\begin{example}{%
В первом случае число 1 сработало, как истинное значение: форма \s{if} вернула второй аргумент. <<По-настоящему>> ложной является только константа \s{\#f}.}
\REPL
  {(if 1 2 3)}
  {2}
\REPL
  {(if \#f 2 3)}
  {3}
\end{example}


Роль операторов сравнения для числовых данных выполняют функции \s{=}, \s{<}, \s{>}, \s{<=} и~\s{>=}.

\begin{example}{%
Примеры использования функций сравнения.}
\REPL
  {(< 2 3)}
  {\#t}
\REPL
  {(= 2 2.0)}
  {\#t}
\end{example}

\vspace{-\medskipamount}
\begin{example}{%
Операторы сравнения могут принимать более двух аргументов, в~таком случае выполняется проверка на~одновременное выполнение условия для всех последовательных пар аргументов.}
\REPL
  {(> 5 4 3 2 1)}
  {\#t}
\REPL
  {(< 2 3 4 3)}
  {\#f}
\end{example}

\index{предикат}Условия можно описывать явно, например, с~помощью операторов сравнения, или оформлять их в~виде именованных функций-предикатов. По~договорённости, имена предикатов заканчиваются знаком <<\s{?}>>. Например, \s{integer?}, \s{positive?}, \s{zero?}, \s{even?}, \s{odd?} и~т.\,п.

Использование именованных предикатов вместо явных условий делает программу более легко читаемой и~считается хорошим стилем.

\begin{example}{Так можно определить модуль от~действительного числа. Здесь мы использовали предикат \fun{negative?}{x}, возвращающий значение \s{\#t} для отрицательных значений \lex{x}.}
\begin{ExampleCode}[emph=x]
> (define (abs x)
    (if (negative? x) 
        (- x) x))
\end{ExampleCode}

\REPL
  {(abs 4)}
  {4}

\REPL
  {(abs -4)}
  {4}
\end{example}

Если требуется выполнение нескольких условий, их можно комбинировать с~помощью логических операций \si{and}, \si{or} и~\si{not}.


\begin{example}{Определим предикат принадлежности числа к~множеству натуральных чисел.\fnindex{natural?}}
\begin{ExampleCode}
(define (natural? x)
  (and (integer? x)
       (positive? x)))
\end{ExampleCode}
\end{example}

При необходимости создания более двух ветвей выполнения, вместо вложенных форм \s{if} используется форма \sfi{cond}:
\begin{SchemeCode}
(cond
  [test1 expr1]
  [test2 expr2]
  ...
  [else expr])
\end{SchemeCode}

Вас не~должны смущать квадратные скобки, они играют ту же самую роль, что и~круглые и~всегда можно обойтись без~них. Более того, в~программе \DrRacket символы квадратных скобок почти всегда автоматически заменяются на~круглые, за~исключением некоторых специальных форм.

Выражение \s{expr}, указанное после ключевого слова \s{else} выполняется в~том случае, когда ни~одно из~условий \s{test1}, \s{test2}, ... не~вернуло истинного значения. Ветви \s{else} может и~не быть.

\begin{example}{\label{example:sign}Определение функции $sign(x)$, возвращающей знак числа.}
\begin{ExampleCode}
(define (sign x)
  (cond
    [(negative? x) -1]
    [(zero? x) 0]
    [else 1]))
\end{ExampleCode}
\end{example}

Логические операции \s{and} и~\s{or} так же можно использовать, в качестве операторов ветвления, поскольку они производят вычисления только тех аргументов, которые могут изменить результат:

\begin{example}{%
В этих примерах второй аргумент не~вычисляется. Поскольку для любого $x$ верно, что

$true\ \text{или}\ x = true$

$false\ \text{и}\ x = false$}
\REPL
  {(or (< 1 2) (/ 1 0))}
  {\#t}
\REPL
  {(and (< 2 1) (/ 1 0))}
  {\#f}
\end{example}

\begin{example}{Так можно определить предикат с~охраной, возвращающий \s{\#t} только для положительных действительных чисел и~\s{\#f} для всех прочих объектов. Использование предиката \s{positive?} для двух последних случаев вызвало бы сообщение об~ошибке.}
\begin{ExampleCode}
> (define (positive-num? x)
    (and (real? x)
         (positive? x)))
\end{ExampleCode}
\REPL
  {(positive-num? 6)}
  {\#t}
\REPL
  {(positive-num? 2-i)}
  {\#f}
\REPL
  {(positive-num? "abs")}
  {\#f}
\end{example}

\section{Система типов языка \Scheme}%
\Scheme~--- язык со \index{динамическая типизация}\emph{строгой динамической типизацией}. Это означает, что проверка типов выражений производится в~процессе выполнения программы, а не во время компиляции. Типы в языке выполняют идентификационную и охраняющую роль; оптимизации, основанной на типах, в языке нет.

Тип данных связывается с величиной, а не с переменной, и представляет множество, к которому принадлежит величина. При этом любая величина может принадлежать к неограниченному числу типов.

\label{set-definition}Как известно, любое множество может быть задано \emph{перечислением}, с помощью \emph{определяющего предиката}, через \emph{индуктивное определение}, или \emph{алгебраически} --- в виде комбинации других множеств (объединения, пересечения или отрицания). Все эти способы применимы и для определения типов. Об индуктивных определениях мы поговорим позже, а пока обсудим прочие способы.

Любая константа (число, строка, символ и т.д.) принадлежит \index{тип!единичный}\emph{единичному типу} --- множеству из одного элемента. Любая величина принадлежит \index{тип!высший}\emph{высшему типу} \sbi{Any}.

Любой предикат может определять тип. Например, предикат \s{odd?} определяет множество нечётных чисел, а предикат \s{positive?} --- множество положительных чисел. К \index{тип!примитивный}примитивным типам данных, определённым через предикаты, относятся:

\vspace{-\medskipamount}
\begin{type}
  \item Bool --- {\TextCommentлогические константы: \s{#t} или \s{#f},}
  \item Num --- {\TextCommentчисла (комплексные),}
  \item Real --- {\TextCommentвещественные числа,}
  \item Int --- {\TextCommentцелые числа,}
  \item Sym --- {\TextCommentсимволы,}
  \item Str --- {\TextCommentстроки,}
  \item Fun --- {\TextCommentфункции.}
\end{type}

Объединение, пересечение и дополнение типов производится с помощью \emph{комбинаторов типов}: \s{$\cup$}, \s{$\cap$} и \s{\\}\footnote{Символы $\cap$ и $\cup$ вводятся, как \s{\\cup}, \MenuItem{Alt}+\s{\\} и \s{\\cap}, \MenuItem{Alt}+\s{\\}.}. Приведём примеры:

\begin{example}{множество, состоящее из трёх элементов: 1, 5 и 8;}
  \begin{ExampleCode}
  ($\cup$ 1 5 8)
  \end{ExampleCode}
\end{example}
\vspace{-\bigskipamount}
\begin{example}{множество натуральных чисел;}
  \begin{ExampleCode}
  ($\cap$ Int positive?)
  \end{ExampleCode}
\end{example}
\vspace{-\bigskipamount}
\begin{example}{множество всех действительных чисел, кроме нуля.}
  \begin{ExampleCode}
  (\\ Real 0)
  \end{ExampleCode}
\end{example}

Если тип определён предикатом, то проверить принадлежит ли величина тому или иному типу можно просто применив предикат к величине. Более универсальную проверку выполняет функция \sbi{is}.

\begin{example}{%
Функция \s{is} позволяет определять принадлежность к единичным типам и не прерывает выполнение программы в случае, если проверка типа приводит к ошибке. Например, функцию \s{odd?} нельзя применять к нецелым числам.}
\REPL{(is 5 Int)}{#t}
\REPL{(is 5 5)}{#t}
\REPL{(is 5.4 odd?)}{#f}
\end{example}

Для конструирования новых именованных типов служит форма \s{define-type}.

\begin{example}{%
Так определяется тип величины, которая может быть равна 3, 5, или любому чётному числу, за исключением 4.}
\begin{ExampleCode}
> (define-type A
    3 5 (\\ even? 4))
\end{ExampleCode}
\REPL{(is 3 A)}{#t}
\REPL{(is 2 A)}{#t}
\REPL{(is 4 A)}{#f}
\end{example}


\begin{Assignment}
а) Используя форму \s{if} или логические операции, напишите предикат \fun{divisible?}{x y}, определяющий делятся ли нацело вещественные числа \lex{x} и \lex{y}. 

\begin{Specification}
(test
  (divisible? 4 2)
  (not (divisible? 4 3))
  (divisible? 7 3.5)
  (divisible? 7.5 -2.5)
  (not (divisible? 2.5 1))
  (not (divisible? 1 0)))
\end{Specification}

б) Определите числовой тип для множества $\{\pi k\ |\ k \in 1,2, ...\}$.

в) Определите функцию 
\begin{equation*}
\mathrm{sinc}(x) = \left\{
\begin{array}{lll}
  \frac{\sin(x)}{x} &\text{если}& x \neq 0,\\
  1 &\text{если}& x = 0,\\
  0 &\text{если}& x~\text{кратно}~\pi.
\end{array}\right. 
\end{equation*}
 
\fnindex{sinc}
\begin{Specification}
(test
  (sinc 2)        ==> (/ (sin 2) 2)
  (sinc pi)       ==> 0
  (sinc (* 6 pi)) ==> 0
  (sinc 0)        ==> 1)
\end{Specification}
\end{Assignment}



\section[2]{Программы \Scheme}%
Введённые в~окне интерпретатора определения, хоть и~работают, программой не~являются. При~выходе из~\Lang{DrRacket} все они будут потеряны. Естественно сохранить их в~файл, затем, чтобы использовать в~дальнейшем.

Записанные в~верхней половине окна \Lang{DrRacket} и~сохранённые определения превращаются в~полноценную программу, её можно откомпилировать, выполнить, сохранить и~загрузить.

Заголовок простейшей программы должен состоять из~указания языка, на~котором она написана. Для использования \Scheme, следует указать заголовок \s{#lang formica}:

\begin{example}{Напишем небольшую программу.

В ней мы определяем две функции \s{area} и \s{perimeter} вычисляющие площадь и периметр круга с заданным радиусом.}
\begin{ExampleCode}[emph={r}]
#lang formica

 (define (area r)
   (* pi (sqr r)))

 (define (perimeter r)
   (* 2 pi r))
\end{ExampleCode}
\end{example}

Сохраним эту программу под~именем, скажем, \s{circle.rkt}. Нажатие клавиш \MenuItem{F5} или \MenuItem{Ctrl+T} заставит \Lang{DrRacket} выполнить её. После этого, мы можем воспользоваться определёнными в~программе функциями в~окне интерпретатора.

Нажатие клавиши \MenuItem{F6} позволит просмотреть синтаксическую структуру программы. В~этом режиме, наведение указателя мыши на~символ покажет, где дано его определение или где  он используется.


\section[4]{Компиляция и~создание приложений}\label{compilation}%
Для освоения принципов функционального программирования и~характерных для него алгоритмических приёмов и структур данных, нам будет достаточно общения с~интерпретатором. Но \Scheme~--- это язык для решения прикладных задач и, если перед нами встаёт задача создания приложения (файла, исполняемого операционной системой), программу надо будет откомпилировать. При~этом необходимо позаботиться о~вводе данных и~о выводе результата.

Приведём пример простейшей программы с~вводом-выводом:
\begin{Definition}[emph={r}]
#lang formica
; определения
(define (area r) (* pi (sqr r)))

(define (perimeter r) (* 2 pi r))

; input
(display "Enter the radius:")
(define r (read))
; output
(printf "Area: ~a" (area r))
(newline)
(printf "Perimiter: ~a" (perimeter r))
\end{Definition}


Здесь мы использовали следующие функции: \bfun{display}{text}~--- выводит сообщение с~текстом \lex{text}; \bfun{read}{}~--- функция без аргументов, которая считывает выражение (последовательность символов до~пробела, символа перевода строки или табуляции) с устройства стандартного ввода; \bfun{newline}{}~--- выводит символ перевода строки.

Все эти функции по~умолчанию работают со~стандартными портами ввода и~вывода: \s{stdin} и~\s{stdout}. Однако, им можно указать порт, который может быть, например, файлом или строкой. Подробнее об~этом можно узнать из~документации \Lang{Racket}.

Далее, в~меню программы \Lang{DrRacket} выбираем \MenuItem{Racket | Создать исполняемый файл...} В~появляющемся диалоговом окне мы можем указать имя и~расположение создаваемого исполняемого файла, его тип и~используемый компилятор (\s{racket} или \s{gracket}\Lang{\footnote{\s{racket}~--- это компилятор \Racket, создающий эффективный код. \s{gracket}~--- это <<отладочный>> компилятор, который сообщает об~ошибках в~окне исполняемого приложения. Для отладки лучше использовать \s{gracket}, для создания конечного приложения~--- \s{racket}.}}).

Типы создаваемых файлов бывают следующими:

\begin{itemize}[--]
 \item \MenuItem{Запуск в~оболочке}~--- создаётся скомпилированный файл, исполняемый в~оболочке \Lang{DrRacket}. Этот тип бывает нужен для отладки программ.

 \item \MenuItem{Автономный}~--- создаётся компактный исполняемый файл, использующий динамические библиотеки \Lang{DrRacket}.

 \item \MenuItem{Дистрибутив}~--- создаётся автономный исполняемый файл, включающий в~себя все необходимые для его работы динамические библиотеки.
\end{itemize}

После нажатия кнопки \MenuItem{Создать}, в~указанной директории появится исполняемый файл с~расширением \s{exe} для ОС Windows или без~расширения для Linux.

Мы больше не~будем заострять внимание на~компиляции и~инструментах ввода-вывода. В~языке \Scheme они реализованы вполне стандартным образом, как и~в большинстве прочих языков: в~виде работы с~портами и~потоками ввода-вывода. Есть в~этом языке и~весьма полный инструментарий для создания оконных приложений. Заинтересованный читатель всегда может обратиться к~руководству по~языку, включённому в~дистрибутив программы \Lang{DrRacket}.

\begin{Queeze}
 \item Какие синтаксические конструкции есть в~языке \Scheme?

 \item Как можно с~помощью \Scheme вычислять арифметические выражения?

 \item Как в \Scheme запоминать вычисленные значения для дальнейшего использования?

 \item Как создавать свои функции в \Scheme?

 \item Какие есть конструкции выбора в \Scheme?
\end{Queeze}
