%!TEX root = main.tex
\Lesson{Отложенные вычисления}\label{Less:delayed-computation}
\

\section[2]{Стратегия вычислений}%
\label{normal-order}Мы уже рассказывали, каким образом интерпретатор \Scheme вычисляет выражения: сначала вычисляются оператор и~операнды, а~затем получившаяся процедура применяется к~получившимся аргументам (см. Занятие \ref{Less:functions}, стр.\,\pageref{applicative-order}).

Существует и~другая модель, в~которой вычисление аргументов не~производится до~тех пор, пока не~понадобится их значение. Вместо этого в~функцию подставляются выражения-операнды, до~тех пор пока не~получится выражение, в~котором присутствуют только элементарные операторы, и~лишь затем производится вычисление всего выражения. Этот второй метод известен под~названием \index{порядок вычисления!\emph{нормальный}}\emph{нормальный порядок вычислений}.

Вычисления, основывающиеся на~аппликативном порядке, называются \index{вычисления!интенсивные}\emph{интенсивными}, а~на нормальном~--- \index{вычисления!ленивые}\emph{ленивыми}. Существуют \index{языки программирования!\emph{ленивые}}\emph{ленивые языки программирования} в~которых используется только нормальный порядок вычислений. Ярким примером таких языков является язык \Lang{Haskell}.

\section[2]{Специальные формы}\index{специальная форма}%
В языке \Scheme преимущественно используется аппликативный порядок вычисления выражений. Но никакой язык программирования не~сможет обойтись только им. 

Рассмотрим, для примера, как выполняется конструкция ветвления \s{(if test? P${}_1$ P${}_2$)}. В~зависимости от~результата процедуры \s{test?}, может быть выполнена либо процедура \s{P${}_1$} либо \s{P${}_2$}. Нам незачем сначала вычислять и~ту и~другую ветвь с~тем, чтобы выбрать результат одной из~них. Поэтому вычисление формы \s{if} не~должно подчиняться аппликативному порядку. 

Мы называем \s{if} или~\s{cond} не~функциями, а~\emph{специальными формами}~--- то есть конструкциями языка с неаппликативным порядком вычисления. Специальные формы сначала оперируют переданными им в~качестве аргументов выражениями, не~вычисляя их, и~только затем проводят вычисления, если это необходимо.

В~виде специальных форм определены и~логические операции \s{or} и~\s{and}. К~специальным формам относятся также \s{define} и~\s{lambda}~--- тела функций, которые описываются с~их помощью, не~должны вычисляться прежде, чем эти функции будут вызваны.


\section{Макропрограм\-мирование}\index{макрос}\label{macro}%
Возможность вводить в~язык \Scheme специальные формы обеспечивается механизмом \emph{макросов}. Макрос описывает \emph{синтаксическое преобразование выражения без~его вычисления}. \Scheme имеет чрезвычайно богатые средства для макропрограммирования.  

Здесь мы не~будем подробно останавливаться на~технике написания макросов, а~только укажем, как можно создать простейшую специальную форму с~их помощью. В~самом простом случае, описание макроса с именем \lex{name} имеет следующий вид:

\bsfindex{define-syntax-rule}
\begin{Specification}[emph={name,pat}]
(define-syntax-rule (name pat)
    body)
\end{Specification}

\noindent Здесь \lex{pat}~--- образец трансформируемой формы. В~элементарном случае, он может быть оформлен, подобно тому, как это делается в~определениях с~помощью формы \s{define}. Выражение \s{body} представляет собой выходное выражение, в~которое трансформируется форма.

Вот, например, определение простейшей формы \si{or}, выполненное с~помощью макроса:

\sfindex{or}
\begin{Definition}[emph={x,y}]
(define-syntax-rule (or x y)
  (if x x y))
\end{Definition}

Это определение предписывает выражение \s{(or x y)} переписать, как \s{(if x x y)}. Именно \emph{переписать} и~только потом вычислить. Основное отличие макроса от~обыкновенной функции и~состоит в~том, что его трансформация происходит до~начала выполнения программы. При~этом не~используются никакие связывания, возникающие во~время исполнения программы. Такой подход, характерный для языка \Lang{Scheme}, получил название «гигиеничный макрос».

\section{Когда использовать макросы?}%
Макропрограммирование позволяет существенно расширять синтаксис языка, добавляет ему выразительности и~делает его более предметно ориентированным. Однако, если какие-то из~этих задач можно решить с~помощью функций, стоит использовать функции.

\index{объект первого класса}Важным отличием синтаксической формы от~функции является то, что формы \emph{не являются объектами первого класса} языка \Scheme. Их невозможно комбинировать с  другими функциями. Для этого специальные формы приходится «прятать» внутрь функций.

Кроме того, как мы уже говорили, макросы позволяют обходить аппликативный порядок вычислений. Это полезно, но только если это происходит осознанно, и~оправдано постановкой задачи. В~противном случае, нарушается стройность и единообразие функционального подхода, обеспечивающие его гибкость и расширяемость. К тому же, злоупотребление макросами может существенно затруднить анализ и отладку программы.

Таким образом, можно сказать, что макросы нужно применять только тогда, когда без~них обойтись невозможно.

\section{Отложенные вычисления}%
\label{delay}Несмотря на~то, что \Scheme не~является ленивым языком, мы можем расширить его так, что нам станут доступны некоторые приёмы ленивых вычислений.

\index{вычисления!отложенные}\emph{Отложенные вычисления} базируются на~том, что мы можем задержать вычисление того или иного выражения до~тех пор, пока это нам не~потребуется. Основой для реализации отложенных вычислений будут форма \s{(~ expr)}, оставляющая выражение \s{expr} невычисленным, и~функция \si{!}, которая вынуждает произвести задержанное вычисление.
\label{lazy}Вот, пример простейшей реализации этой пары:

\begin{Definition}
(define-syntax-rule (~ expr)
  (lambda () expr))

(define (! expr) (expr))
\end{Definition}

Вычисления задерживаются с помощью \lmфункции. Здесь мы пользуемся тем, что \lmфункция не~вычисляет своё тело до~тех пор, пока она не~будет вызвана с~каким-либо аргументом. А~функция \s{(lambda () expr)} не~будет требовать никаких аргументов. Такую структуру называют термином \emph{санк}\index{санк} (англ. \emph{thunk}). Функция \s{!} \emph{вычисляет} эту функцию, вызывая её без аргументов.

Покажем, зачем могут понадобиться ленивые вычисления, на~примере обобщения рекурсивного обхода списка в~виде свёртки. Недостатком свёртки является то обстоятельство, что независимо от~необходимости, список проходится полностью. Тогда, как, например, для функции \fun{any}{test? lst}, проверяющей, есть ли в~списке \lex{lst} элементы, удовлетворяющие условию \lex{test?}, следовало бы остановить поиск, как только найдётся первый подходящий элемент. Вот каким образом мы можем определить эту функцию через свёртку:

\begin{Definition}[emph={el,res,test?,lst}]
(define/c (any test?)
  (foldr (lambda (el res) (or (test? el) res)) #f))
\end{Definition}

Свёртка~--- достаточно мощная и~удобная абстракция, и~отказываться от~неё не~хотелось бы. Вместо этого, модифицируем её, определив ленивую свёртку\index{свёртка!ленивая}\fnindex{foldr~}:

\begin{Definition}[emph={f,lst,h,t}]
(:: foldr~ ((Any Any -> Any) Any list? -> Any)
 (define/c (foldr~ f $x_0$)
   (/. '() --> $x_0$
       (cons h t) --> (f h (~ (foldr~ f $x_0$ t))))))
\end{Definition}
Определяя функцию \s{foldr~}, мы с~помощью формы \s{~} задерживаем рекурсию, откладывая на~потом вычисление второго аргумента функции \lex{f}.

Посмотрим, как воспользоваться ленивой свёрткой, для определения функции \s{any?}:

\begin{Definition}[emph={test?,lst,el,res}]
(define/c (any~ test?)
  (foldr~ (lambda (el res) (or (test? el) (! res))) #f))
\end{Definition}
Теперь вычисление второго аргумента сворачивающей \lmфункции происходит только тогда, когда тест для очередного элемента не~выполняется. Если же тест пройден успешно, форма \s{or} возвращает \s{#t} и~рекурсия заканчивается.
\newpage

\begin{Assignment}
Так как мы работаем в рамках чистого функционального программирования, поведение функций \s{any} и \s{any~} будет неотличимым: на одинаковых данных они всегда возвращают одинаковый результат, так что тесты не выявят разницы в вычислительном процессе. Чтобы убедиться в том, что ленивый вариант действительно ленив, нужно добавить какой-либо побочный эффект, например, вывод промежуточных результатов. 

\label{verbose}
Напишите простой оператор \fun{verbose}{f}, преобразующий любую функцию \lex{f} в <<говорящую>>:
\REPLin{((verbose +) 1 2)}\vspace{-\smallskipamount}
\REPLout{ (+ 1 2)}
\REPLout{3}
\REPLin{(map (verbose sqr) '(2 4 5)}\vspace{-\smallskipamount}
\REPLout{ (sqr 2)}\vspace{-\smallskipamount}
\REPLout{ (sqr 4)}\vspace{-\smallskipamount}
\REPLout{ (sqr 5)}
\REPLout{'(4 16 25)}

С её помощью убедитесь в том, что функция \s{any~}, в отличие от \s{any}, завершает работу вовремя.

\end{Assignment}

\section[2]{Ленивая свёртка}%
Построенная нами абстракция ленивой обработки списка имеет существенный недостаток:
для того, чтобы ею воспользоваться, пришлось в определении функции \s{any~} переписывать сворачивающую \lmфункцию, использовать внутри неё функцию \s{!} и задействовать особые свойства формы \s{or}. Между абстракцией и функцией её использующей должен выстраиваться \emph{барьер абстракции}: функция \s{foldr} <<знает>>, как устроен список, когда он заканчивается и как получить доступ к его частям. Функция \s{any} <<знает>> что она ищет, и ей неважно, как устроен список; <<низкоуровневые>> функции \s{cons}, \s{car} и \s{cdr} находятся на другом уровне абстракции и скрыты от неё. В нашем случае, функция \s{!} явно принадлежит более низкому уровню абстракции, чем функция \s{any}, а знание особых свойств формы \s{or}, отражают необходимость знать, как именно работает функция \s{foldr~}. В таких случаях говорят об утечке абстракции (leaky abstraction).

Этого можно избежать, если ленивую свёртку организовать следующим образом:

\label{lazy-fold}
\begin{Definition}[emph={f,lst,h,t}]
(:: foldr~ ((Any Any -> Any) Any list? -> Any)
  (define/c (foldr~ f $x_0$)
    (/. '() --> $x_0$
        (cons h t) --> (! (f h (~ (foldr~ f $x_0$ (! t))))))))
\end{Definition}

\noindent
В новом определении свёртки <<внешний>> \s{!} продолжает вычисления в случае, если функция \lex{f} возвращает задержанный второй аргумент, а <<внутренний>> требуется если сворачиваемый список также был создан ленивой функцией. Такое решение обеспечивает б\'{о}льшую модульность, поскольку вся информация о характере вычислений сосредотачивается в функции свёртки.

Однако, для того, чтобы новое определение свёртки заработато, нужно немного изменить определение для функции \s{!}. Дело в том, что ленивая свёртка может возвращать задержанное значение, которое будет ещё раз задержано перед рекурсивным вызовом, и одного применения функции \s{!} для запуска рекурсии не хватит. Чтобы такое многократное задерживание не помешало, сделаем так, чтобы функция \s{!} продолжала вычислять задержанные выражения до тех пор, пока они не перестанут быть задержанными. Для этого нам необходимо отличать задержанные вычисления от любых других. Ниже приводится усовершенствованная реализация формы \s{~} и функции \s{!}, использующая абстрактный тип для задержанных вычислений.
\begin{Definition}
(define-type (delayed Any))

(define-syntax-rule (~ expr)
  (delayed (lambda () expr)))

(define !
  (/. (delayed expr) --> (! (expr))))
\end{Definition}
\noindent
Если выражение не является задержанным, итеративная подстановка в определении функции \s{!} вернёт его без изменений, а задержанное --- вычислит столько раз, сколько потребуется.

Теперь можно использовать определение функции \s{any~}, не отличающееся от неленивого:
\begin{SchemeCode}[emph={el,res,test?,lst}]
(define/c (any test?)  (foldr  ($\circ$ or test?) #f))
(define/c (any~ test?) (foldr~ ($\circ$ or test?) #f))
\end{SchemeCode}
Видно, что вся информация о характере вычислений сосредоточена в функции свёртки. Кроме того, стало возможным использовать \s{or}, как функцию, не полагаясь на какие-либо исключения из общих правил вычисления функций.
Кроме того, функция \s{foldr~} является примером построения \emph{стандартного интерфейса}, позволяющего использовать функции со сходной семантикой сходным образом.

\section[2]{Потоки данных}%
\index{отложенные списки}%
\index{поток}%
Итак, мы построили ленивый аналог для свёртки списка, а значит, с её помощью можно определить ленивые аналоги для всех функций, определённых в главе \ref{Less:fold}. Давайте посмотрим, что мы получим в результате ленивого отображения списка:
\begin{Definition}[emph={f}]
(define/c (map~ f) (foldr~ ($\circ$ cons f) '())) 
\end{Definition}
\REPLin{(define s (map~ (hold 'f) '(a b c)))}
\REPL{s}{'((f a) delayed <#procedure>)}
Вычисленным оказалась только голова полученного списка, вычисление хвоста пока осталось задержанным. Попробуем вычислить хвост:
\REPL{(! (cdr s))}{'((f b) delayed <#procedure>)}
Получили второй элемент списка и вновь задержанное выражение в качестве хвоста. Таким образом, функция \s{map~} возвращает последовательность пар с задержанными вторыми элементами:
\begin{SchemeCode}
((f a) . (~ ((f b) . (~ ((f c) . (~ null))))))
\end{SchemeCode}
Такая структура называется \emph{ленивым списком}, или \emph{потоком}~--- последовательностью данных, каждый элемент которой, вычисляется по требованию. Это очень полезная структура, позволяющая изящно решать самые разнообразные задачи.

Поток устроен так же, как и~обыкновенный список~--- в~виде последовательности вложенных точечных пар. Эти две структуры подобны, а значит можно организовать для потока стандартный интерфейс: конструктор и селекторы, назовём их, соответственно \s{cons~}\sfindex{cons~}, \s{car~} и~\s{cdr~}.

\label{lazy-cons}Вот один из возможных вариантов их реализации: 

\newpage
\begin{Definition}[emph={h,t,s}]
(define-syntax-rule (cons~ h t)
 (cons h (~ t)))

(:: car~ (pair? -> Any)
 (define (car~ s) (car s)))

(:: cdr~ (pair? -> Any)
 (define (cdr~ s) (! (cdr s))))
\end{Definition}

Конструктор \s{cons~} должен быть формой, а не функцией, поскольку он должен задержать вычисление своего второго аргумента. Функция \s{car~} просто возвращает первый элемент пары, а~функция \s{cdr~} \emph{вычисляет} второй элемент с~помощью функции \s{!}. Таким образом, вычисление второго элемента будет происходить только при~вызове \s{cdr~}.

\begin{example}{Попробуем составить какую-нибудь пару. Как и~ожидалось, вторым её элементом является задержанная функция, а~\s{cdr~} от~нашей пары вынуждает провести отложенные вычисления.}
\REPLin
  {(define x (cons~ 1 2))}
\REPL
  {x}
  {(1 delayed \#<procedure>)}
\REPL
  {(car~ x)}
  {1}
\REPL
  {(cdr~ x)}
  {2}
\end{example}

А теперь, давайте напишем следующее определение:

\begin{Definition}
(define ones (cons~ 1 ones))
\end{Definition}

Если бы мы следовали подстановочной модели с~аппликативным порядком вычислений, то незамедлительно получили бы бесконечную рекурсию или сообщение об~ошибке. Однако, в~случае отложенных пар, мы описали нечто вполне осмысленное. Посмотрим, что мы получим, вычисляя \s{ones} и~его части:

\REPL
  {ones}
  {(1 delayed \#<procedure>)}

\REPL
  {(cdr~ ones)}
  {(1 delayed \#<procedure>)}

\REPL
  {(cdr~ (cdr~ ones))}
  {(1 delayed \#<procedure>)}
\newpage%
\noindent%
Сколько бы раз мы ни~вычисляли \s{cdr~} от~пары \s{ones}, мы всегда будем получать один и~тот же результат и~никогда не~достигнем какого-либо конца. Эффективно, \s{ones} ведёт себя, как \emph{бесконечная} последовательность (поток) единиц: \s{(1 . (1 . (1 . ...)))}!

Мы будем считать концом потока (если он не~бесконечен), объект \s{null}, также, как для списков. Дадим определение полиморфного алгебраического типа для потока:

\begin{Definition}
(define-type (Stream A)
  '()
  (cons: A delayed?))
\end{Definition}
\REPL{(is ones (Stream 1))}{#t}

\noindent%
Приведём ещё один пример бесконечного потока:

\begin{Definition}[emph={n}]
(:: enum (Num -> (Stream Num))
 (define (enum n) 
   (cons~ n (enum (+ n 1)))))
\end{Definition}

\REPL
  {(enum 1)}
  {(2 delayed \#<procedure>)}

\REPL
  {(cdr~ (enum 1))}
  {(3 delayed \#<procedure>)}

\REPL
  {(cdr~ (cdr~ (enum 1)))}
  {(4 delayed \#<procedure>)}

Поток \s{(enum $n$)} описывает арифметическую прогрессию с шагом~1, начинающуюся с~$n$.

Создадим способ увидеть нашу последовательность. Напишем функцию, возвращающую список нескольких первых элементов (по умолчанию, шести):
\begin{Definition}[emph={str,n,h,t}]
(:: show ((Stream Any) (? Nat) -> list?)
 (define show
   (/. str   --> (show str 6)
       str 0 --> '()
       '() n --> '()
       (cons h t) n --> (cons h (show (! t) (- n 1))))))
\end{Definition}
Первое правило этой подстановки указывает, какое значение счётчика использовать по умолчанию. Следующие два правила завершают формируемый список в случае окончания потока или обнуления счётчика, третье~--- переписывает поток в список, по очереди вычисляя его элементы.

\begin{Assignment}
а) Напишите определения для следующих последовательностей:
\begin{enumerate}
\item \s[emph={a,s}]{(aryth a s)} --- арифметическая последовательность с заданным шагом: $$a, a+s, a+2s, ...;$$
\item \label{iteration}\s[emph={f}]{(iteration f x)} --- последовательность аппликаций заданной функции: $$x, f(x), f(f(x)), ...;$$
\item \s{(powers x)} --- последовательность степеней заданного числа: $$1, x, x^2 , x^3, \ddd .$$
\end{enumerate}


б) Напишите определения следующим функциям для работы с~потоками, используя, где это возможно, ленивую свёртку.

\fun{stream}{. x}~--- конструктор потока, подобный конструктору списка \s{list};
\begin{Specification}
(test 
  (is (stream 1 2 3) (Stream Int))
  (stream)              ==> '()
  (show (stream 1))     ==> '(1)
  (show (stream 1 2 3)) ==> '(1 2 3))
\end{Specification}

\fun{cycle}{a b ...}~--- конструктор цикла $a,b,...,a, b,...$
\begin{Specification}
(test 
  (cycle)              ==> '()
  (show (cycle 1))     ==> '(1 1 1 1 1 1)
  (show (cycle 1 2 3)) ==> '(1 2 3 1 2 3))
\end{Specification}


\label{lazy-filter}\fun{filter~}{p s}, --- возвращает поток элементов \lex{s}, удовлетворяющих условию \lex{p};

\label{until}\fun{until~}{p s}, --- возвращает поток элементов \lex{s}, пока для них не выполнится условие \lex{p};

\begin{Specification}
(test
  (show (until~ (= 4) (enum 1)))        ==> '(1 2 3)
  (show (until~ odd? (stream 2 4 6)))   ==> '(2 4 6)
  (show (until~ even? (stream 2 4 6)))  ==> '())
\end{Specification}

\label{skip-until}\fun{skip-until~}{p s}, --- опускает элементы потока \lex{s}, пока для них впервые не выполнится условие \lex{p};

\fun{map~}{f $s_1$ $s_2$ \ddd}~--- применяет функцию \lex{f} к~элементам одного или более потоков и~создаёт поток результатов;

\begin{Specification}
(test
  (show (map~ sqr (enum 1)))          ==> '(1 4 9 25 36)
  (show (map~ + (enum 1) ones))       ==> '(2 3 4 5 6 7)
  (show (map~ + ones (stream 1 2 3))) ==> '(2 3 4))
\end{Specification}
\end{Assignment}

\section[4]{Пример: решение дифференциального уравнения}%
Рассмотрим часто встречающуюся задачу прикладной математики --- численное решение обыкновенных дифференциальных уравнений первого порядка. Формулировка задачи такова: для заданного уравнения вида $y'=F(x,y)$ и начальных условий $y(x_0)=y_0$ построить таблицу (график) его решения.

Самым простым методом численного решения обыкновенных дифференциальных уравнений является метод Эйлера. Он состоит в последовательном вычислении значений функции $y_n$ на равномерной сетке $x_n = x_0 + n h, n = 0,1,2,...$, согласно соотношению:
$$y_{n+1} = y_n + h F(x_n,y_n).$$

Это соотношение мы запишем в виде простой функции:
\begin{Definition}[emph={f,x,y,h}]
(define (euler h F x y)
  (+ y (* h (F x y))))
\end{Definition}

В качестве примера, рассмотрим, решение, следующей задачи:
$$\label{ode}y'=-x y,\quad y(0)=1.$$

Определим функцию для вычисления правой части уравнения:
\begin{SchemeCode}
(define (F x y) (- (* x y)))
\end{SchemeCode}
\noindent%
Далее, создадим сетку с шагом 0.1 при помощи написанной нами функции \s{aryth} (см. предыдущее задание) и посчитаем на этой сетке последовательность значений $y_n$. Начнём эту последовательность, используя начальное условие задачи, а затем будем применять метод Эйлера, образуя поток значений.
\vspace{-\bigskipamount}
\begin{SchemeCode}[emph={}]
(define x (aryth 0 0.1))

(define y (cons~ 1 (map~ (euler 0.1 F) x y)))
\end{SchemeCode}
\noindent%
Наконец, объединив попарно элементы последовательностей \s[emph={}]{x} и \s[emph={}]{y}, получим решение задачи в виде таблицы:
\REPLin{(show (map~ list x y))}
\REPLout{'((0 1)}\vspace{-\medskipamount}
\REPLout{$~$(0.1 1)}\vspace{-\medskipamount}
\REPLout{$~$(0.2 0.99)}\vspace{-\medskipamount}
\REPLout{$~$(0.3 0.9702)}\vspace{-\medskipamount}
\REPLout{$~$(0.4 0.941094)}\vspace{-\medskipamount}
\REPLout{$~$(0.5 0.90345024))}
Результатом, является потенциально бесконечная последовательность, представляющая численное решение данной задачи.

Если нам потребуется изобразить это решение графически, нужно будет ограничить её некоторым отрезком на оси $x$. Для этого можно написать функцию \s{select-by}, выбирающую из потока часть, удовлетворяющую некоторому условию:
\begin{Definition}[emph={p,s}]
(:: select-by~ ((Any -> Bool) (Stream Any) -> (Stream Any))
  (define (select-by~ p s)
    (until~ p (skip-until~ p s))))
\end{Definition}

Теперь можно воспользоваться функцией \s{points} из библиотеки \s{plot} для того, чтобы нарисовать график решения нашей задачи. Эта функция рисует точечную диаграмму для массива данных, представленного списком. Приведённая ниже программа нарисует решение поставленной нами задачи на отрезке $[0,2]$:
\begin{SchemeCode}
(plot 
  (points (show 
           (select-by~ (lambda (x) (<= 0 (car x) 2))
                       (map~ list x y)))))
\end{SchemeCode}

Обратите внимание на то, что решение задачи полностью формулируется, как оперирование последовательностями. Мы их создаём, комбинируем и пропускаем через <<фильтры>> --- \s{map~} и \s{select-by~}, как если бы они существовали целиком. На самом же деле, ленивые функции вычисляют новые значения создаваемой таблицы по одному, передают их друг другу и только функция \s{show} собирает из них список.

У такого изящного способа вычисления последовательности $y_n$ есть существенный недостаток: всякое вычисление \s{cdr~} от \s{y} запускает полный перебор формируемого функцией \s{map~} списка. В этом можно убедиться, трассируя вызовы функции \s{F}, например, оператором \s{verbose} (см. задание \ref{verbose} на стр. \pageref{verbose}).
\REPLin{(define y (cons~ 1 (map~ (euler 0.1 (verbose F)) x y)))}
\REPLin{(show y 3)}\vspace{-\smallskipamount}
\REPLout{(F 0 1)}\vspace{-\smallskipamount}
\REPLout{(F 0 1)}\vspace{-\smallskipamount}
\REPLout{(F 0.1 1)}\vspace{-\smallskipamount}
\REPLout{(F 0 1)}\vspace{-\smallskipamount}
\REPLout{(F 0.1 1)}\vspace{-\smallskipamount}
\REPLout{(F 0.2 0.99)}\vspace{-\smallskipamount}
\REPLout{'(1 1 0.99)}

Этого можно избежать, если вычисленные однажды выражения заменять на их результат, то есть, если использовать \index{мемоизация}мемоизацию задержанных вычислений. Для этого нужно изменить определение задерживающего оператора:
\begin{Definition}
(define-syntax-rule (delay expr)
  (delayed (memoized (lambda () expr))))
\end{Definition}
Теперь лишние вычисления не производятся:
\REPLin{(show y 3)}\vspace{-\smallskipamount}
\REPLout{(F 0 1)}\vspace{-\smallskipamount}
\REPLout{(F 0.1 1)}\vspace{-\smallskipamount}
\REPLout{(F 0.2 0.99)}\vspace{-\smallskipamount}
\REPLout{'(1 1 0.99)}

Ленивые вычисления практически всегда используют мемоизацию для оптимизации скорости, поскольку на поведении чистых функций мемоизация никак не сказывается.

\begin{Assignment}
а) Напишите функцию \s[emph={F,init,a,b,h}]{(dsolve F init a b h)}, возвращающую в виде таблицы численное решение обыкновенного дифференциального уравнения первого порядка, определённого правой частью \lex{F}, для начальных условий, заданных списком \lex{init} = $(x_0,y_0)$. При построении таблицы, независимая переменная пробегает по отрезку $[a,b]$ с~шагом~\lex{h}.

\newpage
Сделайте так, чтобы эту функцию сразу можно было бы использовать для построения графика решения:
\begin{SchemeCode}[emph={F,init,a,b,h}]
(plot (points (dsolve F init a b h)))
\end{SchemeCode}

б) Метод Эйлера прост, но неточен. Добавьте в функцию \s{dsolve} необязательный аргумент указывающий метод численного решения уравнения. И используйте её с более точным методом Рунге-Кутта второго порядка: $$y_{n+1} = y_n + h F\left(x+\frac{h}2,y_n + \frac{h}2F(x_n,y_n)\right)$$

Сравните решения задачи, приведённой на стр. \pageref{ode}, получаемые обоими этими методами, с её точным решением.

\end{Assignment}

\section{Пример: организация потока ввода}%
Чтобы показать, что использование потоков выходит за рамки чистой математики, покажем, каким образом можно организовать поток данных, считываемых из какого-либо порта (файла или сетевого порта).

Язык \Scheme, как и полагается языку высокого уровня и широкого применения, имеет богатый инструментарий для работы с файлами. Мы же притворимся сейчас, что умеем только открывать файл и считывать оттуда отдельные знаки. Для этого нам понадобится функция \bfun{open-input-file}{name}, открывающая для чтения файл с именем \lex{name} и возвращающая соответствующий порт, а так же функция \bfun{read-char}{port}, читающая знак из указанного порта. 

Поставим перед собой задачу организовать поток чтения слов из файла. Решать её будем следующим образом: сначала построим поток знаков, потом будем выбирать из него части, разделённые знаком-разделителем, например, пробелом, и организуем поток этих частей.

Функция \s{read-char}, считывая очередной знак, смещает указатель на текущую позицию в файле, а это значит, что повторный её вызов приведёт к считыванию нового знака. Эта функция имеет побочный эффект и не является чистой, что свойственно операциям ввода-вывода, но нарушает функциональность программы. Именно поэтому целесообразно организовать считывание данных из файла в виде потока. Можно представить себе, что поток --- это просто список с элементами, совпадающими с содержимым файла. Так как списки и потоки функционально эквивалентны, нам неважно, откуда берётся очередной элемент списка --- получается по ссылке из памяти, или генерируется функцией с побочным эффектом.

Поток знаков мы организуем так же, как и поток единиц \s{ones}, а чтобы ограничить его концом файла, используем функцию \s{until} (см. Задание~\ref{until}, стр. \pageref{until}) и получим окончательный вариант:
\begin{Definition}[emph={p}]
(:: chars (port? -> (Stream char?))
  (define (chars p) 
    (until eof-object? 
           (cons~ (read-char p) (chars p)))))
\end{Definition}
\noindent
Назначение предиката \s{eof-object?} вполне очевидно --- он определяет конец файла. Предикат \s{char?} в сигнатуре функции определяет множество знаков ASCII или Unicode. Они обозначаются в \Scheme с помощью служебных символов \s{#\}. Например, знак \texttt{"a"} (код \s{97}) обозначается, как \s{#\a}. 

Давайте удостоверимся в том, что всё работает. Создадим в текущей директории текстовый файл \texttt{sample.txt} с таким содержанием:
\vspace{-\bigskipamount}
\begin{SchemeCode}
one two three four five six seven eight nine ten
\end{SchemeCode}
\noindent
Теперь откроем этот файл и прочитаем часть потока знаков из~него.
\REPLin{(define ch (chars (open-input-file "sample.txt")))}
\REPL{(show ch)}{'(#\\o #\\n #\\e #\\space #\\t #\\w)}

Имея поток символов, можно приступить к выделению из этого потока отдельных слов, разделённых пробелами. С помощью функции \s{read-char}, мы легко создали поток знаков. Разумно будет построить единообразный интерфейс и создать функцию \s{read-word}, считывающую из порта по одному слову, тогда организация потока слов станет тривиальной задачей.

\begin{Definition}[emph={p,ch,s}]
(:: words (port? -> (Stream Str))
  (define (words p) 
    (until~ eof-object? 
            (cons~ (read-word p) (words p)))))
\end{Definition}

Посмотрим на возможную реализацию функции \s{read-word}:
\newpage
\begin{Definition}[emph={p,ch,s,c}]
(:: read-word (port? -> ($\cup$ eof-object? Str))
  (define (read-word p)
    (let ([ch (chars p)])
      (if (empty? ch)
          eof
          (chars->string (select-by~ not-space? ch))))))

(define (not-space? c) (not (equal? #\space c)))

(define (chars->string s) 
  (apply string (show s +inf.0)))
\end{Definition}
\noindent
Функция \s{read-word} формирует поток знаков из указанного порта, а затем с помощью \s{select-by} выбирает из этого потока части, пропуская пробелы. Функция \s{chars->string} преобразует этот поток знаков в строку, используя базовый конструктор строки \sbi{string}. Поток слов завершается вместе с завершением потока знаков и возвращает символ конца файла \s{eof}.

Удостоверимся в том, что мы получили желаемый результат:
\REPLin{(define w (words (open-input-file "sample.txt")))}
\REPL{(show w)}{'("one" "two" "three" "four" "five" "six")}

С потоком слов можно обращаться, как с любым другим потоком: преобразовывать его, фильтровать и т.д. Пусть, например, нам нужно отыскать в файле слова, начинающиеся на букву \s{"t"}. Для этого мы можем использовать фильтр потоков \s{filter~} (см. Задание~\ref{lazy-filter} на стр.~\pageref{lazy-filter}) и сопоставление в регулярным выражением \s{regexp-match?}.

\REPL
 {(show (filter~ (regexp-match? "^t") w))}
 {'("two" "three" "ten")}

Чего же мы добились использованием потоков? Во-первых, мы создали интерфейс, адекватный процессу последовательного чтения данных из файла и пригодный для обработки универсальными инструментами, оперирующими с потоками.
Во-вторых, мы получили возможность оборвать процесс чтения в любом месте, когда нам это понадобится. Причём это решение мы принимаем не в процедуре низкоуровневого чтения файла, а на самом верхнем уровне – на стадии формулировки задачи. 

Например, для того, чтобы получить только первое слово из файла, начинающееся на \s{"t"} мы наможем написать:
\REPL{(car~ (filter~ (regexp-match? "^t") w))}{''two''}

\noindent
При этом не нужно будет считывать весь файл --- обработка потока завершится, как только будет получен первый его элемент.

\begin{Assignment}
а) Сходство функций \s{chars} и \s{words} наводит на мысль о создании абстракции для порождения потоков с помощью \emph{генераторов} --- функций с побочным эффектом. Имея такую абстракцию, можно было бы, написать такие определения:
\begin{SchemeCode}
(define chars (in-producer read-char))
(define words (in-producer read-word))
\end{SchemeCode}
Создайте с помощью этой абстракции поток случайных чисел, в качестве генератора, используя функцию \s{random}. Что будет, если в генератором будет чистая функция?
\end{Assignment}


\section[4]{Ленивые вычисления \mbox{за~пределами~\Scheme}}%
Отложенные вычисления, в~том или ином виде, встречаются, как в~функциональных языках, так и~в нефункциональных. В~языках, имеющих анонимные функции, можно реализовать отложенные вычисления по~тому же принципу, что мы показали для \Scheme~--- с~помощью функций без~аргументов, задерживающих вычисление своего тела (санков).

Существуют языки программирования, в~которых все вычисления ленивы (\Lang{Miranda}, \Lang{Haskell}, \Lang{Lazy Scheme} и~др.). Это позволяет работать с~любыми списками, как с~потоками.

\begin{Queeze}

 \item В чём состоит отличие аппликативного и~нормального порядка вычисления? Какой порядок вычисления используется для функций в~\Scheme?

 \item Для каких синтаксических конструкций языка \Scheme нарушается аппликативный порядок вычислений?

 \item Как создать макрос в~\Scheme? Как его можно использовать? Когда будет выполняться вызов макроса?

 \item Зачем нужны отложенные вычисления?

 \item Что такое отложенный список? Какие новые возможности даёт использование отложенных списков?

\end{Queeze}
