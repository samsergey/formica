%!TEX root = main.tex
\Lesson{Подстановки и переписывание}\label{Less:rewriting}

\newcommand{\term}{\ensuremath{\mathop{\,\rightarrow\!\!.\,}}}

\section{Семантика  переписывания}\index{переписывание}%
В предыдущих главах мы использовали подстановки\index{подстановка}, в качестве конструктора анонимных функций. Однако, это лишь одно из многих возможных их применений. Основная цель введения подстановок в язык программирования~--- реализация \emph{техники переписывания}.

\emph{Переписывание (rewriting)} --- техника последовательной замены частей формул или термов формального языка по заданной \emph{системе переписывающих правил} (редукционной системе).

Редукционная система, представляет собой упорядоченное множество отношений вида $$P\to E~\quad\text{или}\quad~P\term E,$$ называемых правилами переписывания. Левая часть правила ($P$) называется \emph{образцом} или \emph{шаблоном} и представляет собой выражение, построенное по специальным правилам, которые будут рассмотрены ниже. В правой части ($E$) может находиться произвольное выражение. Правило $P \term E$ называется \emph{терминальным}.

Переписывание осуществляется по следующему алгоритму:

\begin{Algorythm}\label{rewriting-semantics}
  \item Входные данные по очереди сопоставляются с образцами;
  \begin{Algorythm}
    \item в случае успешного сопоставления с образцом, производится соответствующее ему переписывание;
    \item если ни один из образцов не мог быть сопоставлен с данными, последние возвращаются без изменений.
  \end{Algorythm}
  \item Операция подстановки применяется к результату переписывания повторно, начиная с шага 1.
  \item Система останавливается в двух случаях:
  \begin{Algorythm} 
    \item после применения терминального правила,
    \item если в результате подстановки данные не изменяются.
  \end{Algorythm}
\end{Algorythm}

В языке \FLP для реализации описанного процесса переписывания существует форма \sfi{replace-repeated}:

\begin{example}{Определим простую редукционную систему.

Применяя её к~символам \s{'a}, \s{'b}, \s{'c} и~\s{'d}, мы видим, что в~результате переписываний, символы \s{'a} и~\s{'b} преобразуются в~\s{'c}. В~свою очередь, для символа \s{'c} правил нет, и~поэтому он~оставляется без~изменений. То~же относится и~к~символу \s{'d}.
}
  \begin{ExampleCode}
(define f
  (replace-repeated
    'a --> 'b
    'b --> 'c))
  \end{ExampleCode}
  \REPL{(map f '(a b c d))}
       {'(c c c d)}
\end{example}
\begin{example}{В этой редукционной системе первое правило -- терминальное.
Поэтому переписывание символа \s{'a} завершается после первого применения подстановки.}
  \begin{ExampleCode}
(define f
  (replace-repeated
    'a -->. 'b
    'b --> 'c))
  \end{ExampleCode}
  \REPL{(map f '(a b c d))}{'(b c c d)}
\end{example}

\begin{example}{Форма \sfi{replace} создаёт редукционную систему, в которой все правила являются терминальными.}
  \begin{ExampleCode}
(define f
  (replace
    'a --> 'b
    'b --> 'a))
  \end{ExampleCode}
  \REPL{(map f '(a b c d))}{'(b a c d)}
\end{example}


Для обработки алгебраических типов, (списков, деревьев и т.п.), важно иметь возможность применять подстановки не только ко всему входному выражению, но и к его частям. Для этой цели служат формы \sfi{replace-all} (или \sfi{/.}) и \sfi{replace-all-repeated} (или~\sfi{//.}).

\begin{example}{Это правило заменяет символы \s{'a} на \s{'b} и наоборот во всех частях выражения.}
  \begin{ExampleCode}
(define f
  (/. 'a --> 'b
      'b --> 'a))
  \end{ExampleCode}
  \REPL{(f '((a b) (a c d) b))}
       {'((b a) (b c d) a)}
\end{example}

Часто встречающиеся сочетания \s{(define f (/. rules ...))} и \s{(define f (//. rules ...))} можно записать с меньшим количеством скобок, как \s{(define/. f rules ...)} и \s{(define//. f rules ...)}.

\section[4]{Сопоставление с~образцом}\index{сопоставление с~образцом}%
По-настоящему мощной техника переписывания становится при использовании в качестве образцов не констант, а шаблонов.

Шаблонами мы будем называть формы, соответствующие \emph{структуре} передаваемых аргументов. 

Основные виды шаблонов и их синтаксис приведены в таблице.

\medskip
\begin{threeparttable}\small
\begin{tabularx}{\textwidth}{p{3cm}>{\itshape}X<{\smallskip}} \toprule                     
{\bfseries шаблон} & \normalfont\bfseries соответствие и примеры\\

\midrule
Константа, символ или заквотированное выражение & выражение, эквивалентное указанному символу, константе или выражению.\newline \s{1}, \s{2/3}, \s{'x}, \s{'(+ x y)}, \s{#t}\\

\s{x} & Произвольное выражение, которое будет связано с~идентификатором \s{x}.\\

\s{_}  & бланк --- произвольное выражение. \\

\s{(? test?)} \s{(? test? x)} &
Охраняющий шаблон --- соответствует выражениям, удовлетворяющим условию \lex{test ?}. Идентификатор \lex{x} связывается с~таким выражением.\newline \s{(? number?)}, \s[emph=x]{(? symbol? x)}\\

\s{(cons P1 P2)} & Точечная пара элементов, соответствующих шаблонам \s{P1} и~\s{P2}.\newline  \s{(cons h t)}, \s{(cons 1 _)}\\

\s[emph={f,P}]{(list P ...)} & Список из~элементов, соответствующих шаблонам  \lex{P ...}\newline \s{(list 1 2)}, \s[emph=x]{(list _ 'a x)}\\

\s[emph={f,P}]{(+ n y)} & Соответствует числу, при этом с символом \s{y} связывается это число, уменьшенное на \s{n}.\\

\s[emph={f,P}]{(f P ...)} & Объект алгебраического типа, определяемый формальной функцией \lex{f} и~полями \lex{P ...}\\

\s{x ___} &  Последовательность из~произвольного (возможно, нулевого) количества аргументов.\newline \s[emph={x,y}]{(list x y ___)}\\

\bottomrule
\end{tabularx}
\end{threeparttable}
\medskip

\begin{threeparttable}\small
\begin{tabularx}{\textwidth}{p{3cm}>{\itshape}X<{\smallskip}} \toprule                     
{\bfseries шаблон} & \normalfont\bfseries соответствие и примеры\\

\midrule

\s[emph={x,k}]{x __k} &  Последовательность из~\lex{k} и~более аргументов.\newline \s[emph=x]{(list x y __2)}\\

\s[emph={P}]{(or P ...)}
&
Аргументы соответствуют какому-либо из~образцов \lex{P ...} \newline \s{(or 1 2)},  \s[emph=a]{(cons (or 1 2) a)}\\

\s[emph={P}]{(and P ...)} & 
Аргументы одновременно соответствуют образцам  \lex{P ...} Часто используется для связывания идентификатора с~ более сложными образцами.\newline
\s[emph=x]{(and x (or 1 2 3))}, \s[emph={x,h,t}]{(and x (cons h t))}\\

\bottomrule
\end{tabularx}
\end{threeparttable}
\medskip

В \Lang{Racket} существует множество других шаблонов (всего их более~20-ти). Мы перечислили несколько наиболее часто используемых. Полную информацию можно получить по~контекстной справке к~форме \s{match} в документации \Lang{Racket}.

Основная задача сопоставления с~образцом состоит в~том, чтобы распознать структуру переданного выражения и~поименовать, если необходимо, его части.


\section{Интерпретатор для Машины Тьюринга}%
В качестве развёрнутого примера использования подстановок, рассмотрим построение интерпретатора программ для машины Тьюринга~--- абстрактной вычислительной модели, используемой в теории вычислительных процессов для анализа проблемы алгоритмической разрешимости задач и формализации понятия алгоритма.

Она представляет собой бесконечную в обе стороны ленту, разделённую на ячейки (позиции), в которые могут быть записаны символы из заданного алфавита, и управляющее устройство, которое может находиться в одном из заданных программой состояний. Управляющее устройство может сдвигать ленту вправо или влево, считывать и записывать символы в текущей позиции. Алфавит обязательно включает в себя пустой символ, означающий не заполненную ячейку.

Программой для машины Тьюринга является неупорядоченный набор правил перехода. Каждое правило, в зависимости от текущего состояния и наблюдаемого в текущей клетке символа, указывает записать в эту клетку како-либо новый символ, перейти в новое состояние и переместиться на одну клетку влево или вправо. 

Например, в следующей программе
\label{TM-prog}
\begin{align*}
S_0~0 &\to S_1~1~l\\
S_0~1 &\to S_2~0~r\\
S_1~\# &\to E~\#~p
\end{align*}
первое правило перехода предписывает в состоянии $S_0$, в случае символа 0 в текущей позиции, перейти в состояние $S_1$, поместить в текущую позицию символ 1 и после этого сместить ленту на одну позицию влево; второе правило~--- в состоянии $S_0$ при считывании символа 1, перейти в состояние $S_2$, записать вместо 1 символ 0 и сместить ленту вправо; наконец, согласно третьему правилу, в случае считывания пустого символа в состоянии $S_1$, следует перейти в состояние $E$ и, оставив ячейку пустой, ленту не смещать.

Машина останавливается в только том случае, когда ни одно из правил перехода не может быть применено к текущим состоянию и символу на ленте.

Наша задача состоит в создании абстрактного типа данных для представления эффективно бесконечной ленты, а так же, в разработке интерпретатора программ для управляющего устройства машины Тьюринга.


\subsection*{Типы данных}

Наша машина будет писать на ленту и считывать с неё символы или числа. Определим тип для данных, которые можно записать на ленту:
\begin{SchemeCode}
(define-type Data Sym Nat '())
\end{SchemeCode}
\noindent здесь пустой список обозначает пустую ячейку на ленте.

Состояния машины обозначаются символами:
\begin{SchemeCode}
(define-type State Sym)
\end{SchemeCode}

Ленту представим в виде совокупности трёх частей: левой части, текущей позиции и правой части. Левая и правая части будут представлены списками. 

\begin{SchemeCode}
(define-type (Tape (list: Data ..) Data (list: Data ..)))
\end{SchemeCode}

Для типа данных, представляющего ленту, необходимо определить следующие функции: \s{tape}~--- создание ленты с начальной записью, \s{get}~--- считывание символа в текущей позиции, \s{put}~--- запись указанного символа в текущую позицию, \s{shift-right} и \s{shift-left} для перемотки ленты на одну позицию вправо или влево, \s{show-tape}~--- для визуализации записей на ленте.


Вот как можно определить функцию \s[emph={lst}]{(tape lst)}, принимающую список символов и возвращающую ленту с текущей позицией на самом левом символе записанном на ленте.
\begin{Definition}[emph={h,t}]
(:: tape ((list: Data ..) -> Tape?)
  (define/. tape
    (list h t ___) --> (Tape '() h t)))
\end{Definition}
Обратите внимание на то, как мы с помощью образца <<разобрали>> входной список и собрали экземпляр ленты, не прибегая к селекторам \s{first}, \s{rest} и т.\,п.

\begin{example}{Создадим, в качестве примера, ленту с записью "1011011".}
\begin{ExampleCode}
> (tape '(1 0 1 1 0 1 1))
\end{ExampleCode}
\REPLout{(Tape '() 1 '(0 1 1 0 1 1))}
\end{example}

\begin{Assignment}
a) Сдвиг ленты влево требует рассмотрения трёх случаев: 1) текущая позиция находится на левом краю записи на ленте, 2) текущая позиция --- в правом краю записи и 3) общий случай.
 Дополните определение для функции \s{shift-left}
\begin{Definition}
(:: shift-left (Tape? -> Tape?)
  (define/. shift-left
    (Tape '() '() (cons h t)) --> ...   ; левый край записи
    (Tape  l x '())           --> ...   ; правый край записи
    (Tape  l x (cons h t))    --> ...))) ; общий случай
\end{Definition}
\noindent

При этом все три случая должны обрабатываться за время $O(1)$, то  есть, не зависящее от длины записи на ленте.

б) Сдвиг ленты вправо можно свести к левому сдвигу, если поменять местами правую и левую части ленты:
\begin{Definition}
(:: shift-right (Tape? -> Tape?)
  (define shift-right
    (compose flip-tape shift-left flip-tape)))
\end{Definition}
Напишите определение для функции \s{flip-tape}.

\newpage
в) Напишите определения для функций \s{get} и \s{put}.

г) Определите функцию \s{show-tape}, так, чтобы она показывала какая позиция является текущей, например, таким образом: \s{'(a (b) c d)} для текущей позиции, содержащей символ \s{b}.
\end{Assignment}

\subsection*{Интерпретация правил перехода}

Правила перехода для машины Тьюринга естественно представить в виде правил переписывания, а программу~--- в виде подстановки. Например, программа, приведённая на стр. \pageref{TM-prog}, может быть определена таким образом:
\begin{SchemeCode}
(define/. PROG
  '(S0 0) --> '(S1 1 l)
  '(S0 1) --> '(S2 0 r)
  '(S1 ()) --> '(E () p))
\end{SchemeCode}

Опишем тип и для программ, выполняемых машиной Тьюринга. Возможное смещение ленты:
\begin{SchemeCode}
(define-type Shift 'l 'r 'p)
\end{SchemeCode}
\noindent и правила перехода:
\begin{SchemeCode}
(define-type In (list: State Data))
(define-type Out (list: State Data Shift) 
                 In)
\end{SchemeCode}
Программа применяется к паре типа \s{In}: состоянию и символу в текущей позиции, и возвращает тройку имеющую тип \s{Out}: новое состояние, новый символ и направление смещения ленты. Если ни одно из правил не может быть применено, возвращается входная пара \s{In}.

Процесс выполнения программы на машине Тьюринга может быть описан как итеративная подстановка:
\begin{Definition}[emph={S,T,prog}]
(:: run ((In -> Out) -> ((list: State Tape?) -> 
                         (list: State Tape?)))
  (define (run prog)
    (//. `(,S ,T) --> (interprete (prog `(,S ,(get T))) T))))
\end{Definition}

\newpage
Здесь \lex{S} --- текущее состояние машины, \lex{T} --- лента. Программа \lex{prog} преобразует пару \s{`(,S ,(get T))} в тройку имеющую тип \s{Out}. Эта тройка и лента обрабатываются функцией \s{interprete}, которая должна  возвращать обновлённые состояние машины и ленту. К этим данным снова можно применить описанную подстановку. 

Согласно алгоритму применения подстановок (см.~стр.~\pageref{rewriting-semantics}), итеративный процесс завершится в случае, если ни одно из правил программы применено быть не может, что соответствует завершению работы машины Тьюринга.

\begin{Assignment}
  Функция \s{interprete} должна обрабатывать команды, возвращаемые программой, и возвращать новое состояние и изменённую ленту. При этом, если ни одно из правил прехода программы не применяется, программа вернёт не тройку, а пару: состояние и символ в текущей позиции. Этот случай соответствует окончанию работы программы
Завершите определение этой функции.
\begin{SchemeCode}[emph={S,T,v}]
(:: interprete (Out Tape? -> (list: State Tape?))
  (define/. interprete
    (list S x 'r) T --> ...
    (list S x 'l) T --> ...
    (list S x 'p) T --> ...
    (list S _) T --> (list S T))) ; окончание работы
\end{SchemeCode}

Проверьте правильность работы интерпретатора на примере программы, прибавляющей единицу к числу, записанному в двоичной нотации:
\begin{SchemeCode}
(:: ADD1 Program
  (define/. ADD1
    '(Start 1) --> '(Start 1 l) 
    '(Start 0) --> '(Start 0 l) 
    '(Start ()) --> '(Add () r) 
    '(Add 0) --> '(End 1 p) 
    '(Add 1) --> '(Add 0 r) 
    '(Add ()) --> '(End 1 p)))
\end{SchemeCode}
\end{Assignment}

Функция \s{run} уже может выполнять программу и возвращать состояние машины и ленту после остановки. Однако, чаще всего, интерес представляет не конечный результат, а протокол выполнения программы: последовательность состояний и записей на ленте.

Дополним определение функции \s{run} так, чтобы по ходу выполнения программы выводился протокол:
\begin{Definition}[emph={S,T,prog}]
(:: run ((In -> Out) -> ((list: State Tape?) -> 
                         (list: State Tape?)))
 (define (run prog)
   (//. `(,S ,T) --> (begin
                       (show-protocol S T)
                       (interprete (prog `(,S ,(get T))) T)))))%\medskip%

(define (show-protocol S T)
  (printf "~a \t ~a \n" S (show-tape T)))
\end{Definition}

Форма \sfi{begin} задаёт последовательность выполнения нескольких функций, возвращая результат последней из них. Функция \bfun{printf}{s arg ...} выполняет форматированный вывод значений \lex{arg ...}, в соответствии с форматирующей строкой \lex{s} (в приведённом нами примере \s{"\t"} и \s{"\n"}~--- символы табуляции и перевода строки, соответственно, флаг \s{"~a"} обеспечивает вывод аргументов функции).

\subsection*{Реификация машины Тьюринга}
В качестве последнего дополнения, абстрагируем интерпретатор машины Тьюринга, так чтобы, задавая программу для неё, мы получали функцию, способную обрабатывать произвольную запись на ленте и возвращать конечную запись:

\begin{Definition}[emph={l,rules}]
(define-syntax-rule (Turing-Machine rules ___)
  (lambda (t)
    (second ((run (/. rules ___)) (list 'Start t)))))
\end{Definition}

\noindent При этом мы предполагаем, что начальное состояние машины всегда задаётся символом \s{'Start}. 

При определении этого макроса тоже используются образцы: \s{rules ___} обозначает последовательность аргументов. В теле макроса эта последовательность <<вписывается>> в форму \s{/.} и превращается в подстановку.

Теперь мы можем определять, применять и комбинировать машины Тьюринга так же естественно, как и любые другие функции:

\begin{SchemeCode}
(:: ADD1 (Tape? -> Tape?)
 (define ADD1
  (Turing-Machine
    '(Start 1) --> '(Start 1 l) 
    '(Start 0) --> '(Start 0 l) 
    '(Start ()) --> '(Adder () r) 
    '(Adder 0) --> '(End 1 p) 
    '(Adder 1) --> '(Adder 0 r) 
    '(Adder ()) --> '(End 1 p))))
\end{SchemeCode}
\REPLin{(ADD1 (tape '(1 0 1)))}
\REPLout{Program starts}\vspace{-\medskipamount}
\REPLout{Start  ((1) 0 1)}\vspace{-\medskipamount}
\REPLout{Start  (1 (0) 1)}\vspace{-\medskipamount}
\REPLout{Start  (1 0 (1))}\vspace{-\medskipamount}
\REPLout{Start  (1 0 1 ())}\vspace{-\medskipamount}
\REPLout{Adder  (1 0 (1))}\vspace{-\medskipamount}
\REPLout{Adder  (1 (0) 0)}\vspace{-\medskipamount}
\REPLout{End    (1 (1) 0)}
\REPLout{'(Tape (1) 1 (0))}


Функция \s{ADD1} возвращает новую запись на ленте, так что мы можем снова применить к ней эту же программу или другую программу для Машины Тьюринга, обрабатывающую двоичные числа. Вот, так, например, можно определить программу, прибавляющую к двоичному числу тройку: \s{($\circ$ ADD1 ADD1 ADD1)}


Форма \s{Turing-Machine} преобразуется в функцию и таким образом становится объектом первого класса языка \Scheme. Превращение объекта или типа данных в объект первого класса называется его \emph{реификацией}.


\section{Символьные преобразования}%
Переписывание является чрезвычайно удобной техникой для программирования символьных преобразований, поскольку правила переписывания соответствуют аксиомам, используемым при преобразованиях.
Для примера, рассмотрим правило разложения логарифма произведения.
\begin{Definition}
(define-formal ln)%\medskip%
(define//. ln-expand
  (ln x __1 '* y __1) --> `((ln ,x) + (ln ,y)) 
  (ln (? list? x))    --> `(ln ,@x))
\end{Definition}

\newpage
Второе правило предписывает избавляться от лишних скобок, окружающих простые выражения.

Использование формы \s{//.} (\s{replace-all-repeated}) приводит к тому, что преобразования будут сделаны во всех частях выражения.
\REPL{(ln-expand '(ln x * y))}
     {((ln x) + (ln y))}
\REPL{(ln-expand '(5 + (ln x * y)))}
     {(5 + ((ln x) + (ln y)))}
\REPL{(ln-expand '(ln x * y * z))}
     {(((ln x) + (ln y)) + (ln z))}
\REPL{(ln-expand '(ln (x + y) * z))}
     {((ln x + y) + (ln z))}

\begin{Assignment}
Дополните редукционную систему для преобразования логарифмической функции правилами для разложения логарифма разности и степенной функции.

Подумайте, каким образом определяется приоритет обрабатываемых вами арифметических операций.
\end{Assignment}

\section[4]{Сопоставление с~образцом \mbox{за~пределами~\Scheme}}%
Описание процедур с~помощью шаблонов появилось в~языке \Lang{SNOBOL}, в~котором шаблоны являются объектом первого класса. Первым языком, в~котором появились шаблоны для древообразных структур, был \Lisp. Сейчас на~сопоставлении с~образцом базируются такие функциональные языки, как \Lang{Haskell} и~\Lang{OCaml}.
Унификация, как обобщение сопоставления с~образцом, является базовым механизмом в~языке логического программирования \Lang{Prolog}.

Одну из~самых богатых и~последовательных систем программирования с~помощью подстановок демонстрирует язык \Lang{Mathematica}, в~котором подстановки и образцы являются объектами первого класса, и~сопоставление является ключевым механизмом обработки данных.

Кроме этого, шаблоны используются в~языке обработки текстов \Lang{sed, awk, Perl} и~в оболочках операционных систем в~виде регулярных выражений.

С 2001 года успешно развивается язык \Lang{Tom}, добавляющий примитивы для работы с~шаблонами в~языки \Lang{C++} и~\Lang{Java}. Он используется для преобразования XML\=/документов, создания продукционных систем и~систем символьной алгебры.

\begin{Queeze}
 \item В чём состоит отличие в семантике \lmфункций и подстановок? Почему мы можем использовать подстановки для создания \lmфункций?
\end{Queeze}
