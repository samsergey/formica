%!TEX root = main.tex
% revision done
\Lesson{Функции в~\Scheme}%
\label{Less:functions}

% \begin{Abstract}
% Это занятие посвящено функциям --- основе ФП.
% \end{Abstract}

\section[4]{\Scheme~--- функциональный язык}%
Способ определения функций в~\Scheme пока существенно не~отличался от~того, как мы определяем функции в~языках \Lang{С} или \Lang{Pascal}: и~там и~там мы указываем имя функции, какие аргументы она должна получать и~что возвращать. Принципиальное отличие состоит в~том, что именно мы получаем в~результате. В~языках, не~являющихся функциональными, функция или процедура не~имеет смысла в~отрыве от~передаваемых ей аргументов.

\label{first-class}В функциональных языках программирования~--- функция это \index{объект первого класса}\emph{объект первого класса}. Это означает, что мы можем:

\begin{itemize}[--]
 \item связывать идентификаторы с~функцией;

 \item передавать её другим функциям в~качестве аргумента;

 \item возвращать её в~качестве результата;

 \item создавать функции во~время исполнения программы;

 \item идентифицировать функции независимо от~именования.
\end{itemize}

О последних трёх свойствах мы поговорим чуть позже, а~пока проиллюстрируем первые два:

\begin{example}{Мы связали символ \s{f} с~функцией \s{sqr},  как если бы функция \s{sqr} была рядовым объектом данных~--- константой или символом.

При вычислении \s{f} интерпретатор говорит нам, что это функция~\s{sqr}.}
\REPLin{(define f sqr)}
\REPL
  {(f 5)}
  {25}

\REPL
  {f}
  {\#<procedure:sqr>}
\end{example}


\begin{example}{Определим функцию, возвращающую без~изменений свой аргумент (\index{тождественное отображение}тождественное отображение).

\smallskip
Передадим ей в~качестве аргумента функцию \s{+}.

\medskip
Убедимся, что возвращаемая функция действительно является функцией сложения.}
\REPLin{(define (id x) x)}
\REPL
  {id}
  {\#<procedure:id>}
\smallskip
\REPL
  {(id +)}
  {\#<procedure:+>}
\smallskip
\REPL
  {((id +) 5 6)}
  {11}
\end{example}

\index{анонимная функция}
\section{Анонимные функции}%
Что не~даёт программисту возможности обращаться с~функциями, как с~объектами первого класса в~таких языках, как~\Lang{C} или~\Lang{Pascal}? В~них мы можем присвоить некой переменной указатель на~существующую функцию или связать эту переменную с~объектом процедурного типа. Но пока мы не~создадим функцию, то есть не~опишем последовательность действий, которую она должна произвести и, самое главное, не~дадим ей уникального имени, связывать переменную нам не~с чем.

Для того, чтобы функции можно было создавать в~процессе выполнения программы и~возвращать в~качестве результата, необходимо уметь описывать, что должна делать функция со~своими аргументами, не~прибегая к~именованию. \index{функция}В математическом понимании, функция~--- это отображение, то есть «правило», по~которому каждому элементу одного множества~--- \emph{области определения}~--- ставится в~соответствие некоторый элемент другого множества~--- \emph{области значений}. Например, функция, возводящая вещественный числовой аргумент в~квадрат, каждому вещественному числу $x$ ставит в~соответствие число $x \cdot x$. Это правило можно записать, вообще не~давая никакого имени этой функции, например, так, как это принято в математике: $$x \mapsto x\cdot x.$$

Таким образом, для полноценного функционального программирования, нужно уметь отделить абстрактную функцию-правило от~конкретной именованной функции, существующей в~памяти машины. Эту задачу выполняют \emph{анонимные функции} или \emph{\lmфункции}.

Формальную математическую запись функции возведения в~квадрат можно перенести на~язык \Scheme, практически буквально, с~помощью специальной формы \s{lambda} ({\syntaxform \texter{lambda}}):
\index{Formica!базовые формы!lambda@\s{lambda} ({\schemestyle\syntaxform lambda})}
\begin{SchemeCode}[emph={x}]
(lambda (x) (* x x))  
\end{SchemeCode}
Знак \s{lambda} вводится с~клавиатуры комбинацией клавиш \MenuItem{Ctrl + \textbackslash} или с~помощью команды меню \MenuItem{Insert | Insert  lambda}.

\begin{example}{%
Эта анонимная функция удваивает свой аргумент.

Как и любую полноценную функцию, и~её можно использовать в качестве головы выражения.}
\REPL
  {(lambda (x) (* 2 x))}
  {\#<procedure>}
\REPL
  {((lambda (x) (* 2 x)) 3)}
  {6}
\end{example}

В приведённых выше примерах символ \lex{x} является \index{формальный аргумент}\emph{формальным аргументом} \lmфункции. Принципиально то, что какой именно символ используется в~качестве формального, не~имеет значения.
Таким образом, функции \s[emph={x}]{(lambda (x) (* x x))} и~\s[emph={y}]{(lambda (y) (* y y))} эквивалентны.

Вопрос имени формального аргумента становится важен только тогда, когда мы имеем функции в~теле других функций. Например, в~данном случае не~очевидно, чьим аргументом является символ \s{x}:
\begin{SchemeCode}[emph={x,y}]
(lambda (x) (lambda (x y) (* x y)))
\end{SchemeCode}

\noindent Предлагаем читателю самостоятельно разобраться с~помощью интерпретатора, каким образом эти две функции делят символ \s{x}.

Покажем аналогию между \s{lambda} и~\s{define}. Выражения справа и~слева определяют одинаковые по~своему действию процедуры

\label{lambda-arity}
Функция одного аргумента:

\begin{tabular}{*{2}{p{0.5\textwidth}}}
\parbox{0.5\textwidth}
{\s{(define (f arg) body)}}
&
\parbox{0.5\textwidth}
{\s{(lambda (arg) body)}}
\end{tabular}

Функция двух аргументов:

\begin{tabular}{*{2}{p{0.5\textwidth}}}
\parbox{0.5\textwidth}
{\s{(define (f arg1 arg2) body)}}
&
\parbox{0.5\textwidth}
{\s{(lambda (arg1 arg2) body)}}
\end{tabular}
По существу, запись, связывающую функцию с~символом \s{f}:
\begin{SchemeCode}
(define (f arg1 arg2 ...) body)
\end{SchemeCode}
можно переписать так:
\begin{SchemeCode}
(define f (lambda (arg1 arg2 ...) body)),
\end{SchemeCode}
\noindent и эти определения будут эквивалентны.

Анонимные функции играют очень важную роль в~функциональном программировании~--- именно они позволяют создавать функции во~время выполнения программы и~возвращать функции, в~качестве результата. Они же делают функции самоидентифицируемыми, то есть, независимыми от~именования. Благодаря этим свойствам, граница между данными и~функциями в~функциональных языках программирования, фактически, стирается. 

\section{Анонимные~функции и~подстановки}%
В языке \Scheme существует понятие \index{подстановка}\emph{подстановки}~--- замены выражения или его части по~определённым правилам. И хотя семантика подстановок и \lmфункций, в~общем смысле, отличается (см. Занятие~\ref{Less:rewriting}, стр.~\pageref{Less:rewriting}), во~многих случаях, подстановку можно рассматривать, как способ определения анонимной функции.

Форма \s{(/. arg ... --> body)}, определяющая простую подстановку, соответствует форме
\s{(lambda (arg ...) body)}. 

\begin{example}{%
Так можно определить анонимную функцию, удваивающую свой аргумент.}
\REPL
  {(/. x --> (* 2 x))}
  {\#<procedure:rewrite-all>}
\REPL
  {((/. x --> (* 2 x)) 3)}
  {6}
\end{example}
\begin{example}{%
Эта подстановка определяет бинарную функцию, вычисляющую модуль разности для двух чисел.}
\REPL
  {(/. x y --> (abs (- x y)))}
  {\#<procedure:rewrite-all>}
\end{example}
Подстановки отличаются от лямбда-функций тем, что позволяют удобно задавать правила для каких-то определённых значений аргументов, не прибегая непосредственно к формам \s{if} или \s{cond}.

\begin{example}{%
Эта функция, определённая через подстановку, возвращает 0~--- если первый аргумент равен 0, 1~--- если аргументы равны и их разность~--- в общем случае.\newline Форма \s{(define/. f ...)} эквивалентна \s{(define f (/. ...))}. Она избавляет от лишней пары скобок и уменьшает вложенность выражения.}
\begin{ExampleCode}
(define/. f 
  0 x --> 0
  x x --> 1
  x y --> (- x y))
\end{ExampleCode}

\REPL
  {(f 0 2)}
  {0}
\REPL
  {(f 1 2)}
  {-1}
\REPL
  {(f 2 2)}
  {1}
\end{example}

Подробнее подстановки и их применение будут рассмотрены на~Занятии~\ref{Less:rewriting}.

\index{функция!анонимная}
\section{Анонимные~функции \mbox{за~пределами~\Scheme}}%
Анонимные функции реализованы в~полной мере во~всех функциональных языках: \Lang{Haskell}, \Lang{Erlang,} \Lang{OCaml}, \Lang{Clojure}, \Lang{F\#}, \Lang{Ruby} и~т.\,д., как неотъемлемая часть функционального подхода. Однако, это не~значит, что их нет на~пределами функционального мира. Создание анонимных функций возможно во~многих языках программирования: \Lang{C\#}, \Lang{Delphi} (начиная с~версии 2009 г.), \Lang{JavaScript}, \Lang{Perl}, \Lang{PHP}, \Lang{Python}, \Lang{Visual Basic.NET} и~пр. Лямбда-функции планируется ввести в~стандарт языка \Lang{C++0x}. Для \Lang{С++} существует библиотека Boost Lambda Library%
%
\footnote{http://boost.org/doc/libs/1\_45\_0/doc/html/lambda.html} 
%
, в~которой анонимные функции реализуются с~помощью шаблонов.

Приведём простые примеры создания анонимных функций в~этих языках:

\medskip
\begin{tabular}{>{\medskip\small}l>{\ttfamily\small}p{0.75\textwidth}}
\Lang{C\#}
&
Func < \textbf{int} , \textbf{int} > foo = x => x*x;\\

\Lang{C++0x}
&
[](\textbf{int}  x, \textbf{int}  y)\{\textbf{return}  x * y;\} \\

\Lang{Delphi} 
&
y1 := \textbf{function} (x: \textbf{Integer}): \textbf{Integer}

\quad \textbf{begin}

\qquad      Result := x * x;

\quad    \textbf{end};\\

\Lang{JavaScript}
&
\textbf{function} (x)\{\textbf{return}  x*x;\}\\

\Lang{Perl 6}
&
\textbf{my} \$squarer1 = -> \$x \{\$x * \$x\};\\

\Lang{PHP}
&
\$foo = create\_function ('\$x',

\quad'return  \$x*\$x;');\\

\Lang{Python}
&
foo = \textbf{lambda}  x: x*x\\

\Lang{VBasic.NET}
&
\textbf{Dim}  foo = \textbf{Function} (x) x * x
\end{tabular}

Подстановки широко используются в таких языках, как \Lang{Mathematica} и \Lang{Refal}, а подобный им синтаксис --- во многих функциональных языках: \Lang{Haskell}, \Lang{Erlang,} \Lang{OCaml} и т.п.


\begin{Assignment}
Напишите анонимные функции для:

a) тождественного отображения;

б) определения, является ли число натуральным;

в) вычисления среднего арифметического трёх чисел;

г) вычисления полинома $x^2 + 2 x y - y^2$.
\end{Assignment}


\section{Как вычисляет \Scheme?}\label{applicative-order}%
Принцип, лежащий в~основе вычисления выражений в~\Scheme, столь же прост, как и~его синтаксис. Приведём алгоритм вычисления произвольного выражения:


\begin{Algorythm}
  \item Если выражение является атомом, возвращается связанное с~ним значение.
  \item Если выражение является списком:
  \begin{Algorythm}
    \item сначала по~очереди, следуя этому же алгоритму, вычисляются элементы списка;
    \item все вычисленные элементы, начиная со~второго, подставляются в~первый элемент, как аргументы функции, после чего она вычисляется.
  \end{Algorythm}
\end{Algorythm}

Такой порядок вычислений: «сначала вычисляются аргументы, потом~--- функция», называется \index{порядок вычисления!аппликативный}\emph{аппликативным}. При~этом, для того, чтобы вычислить функцию, необходимо, чтобы все аргументы имели какое-либо значение. Язык программирования, в~котором все функции получают \emph{значения} своих аргументов, называется \index{языки программирования!строгие}\emph{строгим}, в~противовес \index{языки программирования!нестрогие}\emph{нестрогим} языкам --- в~них функции получают \emph{имена} своих аргументов. \Scheme~--- строгий язык.

Покажем, в~качестве примера, каким образом вычисляется следующее выражение:
\begin{SchemeCode}
(/ (+ 1 2) (* 3 (- 5 8)))
\end{SchemeCode}
Оно представляет собой список, значит, нужно вычислить по~очереди все его элементы. Мы будем показывать то, что элемент вычислен, подчёркиванием. Начнём с~вычисления головы списка:
\newcommand{\ub}[1]{\underbar{#1}}

\begin{SchemeCode}
(%\ub{<procedure:/>}%  (+ 1 2) (* 3  (- 5 8 )))
\end{SchemeCode}
Символ \s{/} при~вычислении возвращает \emph{функцию деления}. В~этом можно убедиться, вычислив \s{/} в~окне интерпретатора.

Переходим ко~второму элементу. Он так же является списком, поэтому снова нужно по очереди вычислить все его элементы:
\begin{SchemeCode}
(%\ub{<procedure:/>}% (%\ub{<procedure:+>}% 1 2) (* 3  (- 5 8 )))
\end{SchemeCode}
Первый элемент оказался функцией сложения, остальные~---  константами. Подставляем константы в~функцию и~вычисляем её:

\begin{SchemeCode}
(%\ub{<procedure:/>}% %\ub3%  (* 3  (- 5 8 )))
\end{SchemeCode}

Переходим к~третьему элементу, который тоже является списком. По~очереди обрабатываем его элементы и~производим вычисления:

\begin{SchemeCode}
(%\ub{<procedure:/>}% %\ub3% (%\ub{<procedure:*>}% 3 (- 5 8)))
(%\ub{<procedure:/>}% %\ub3% (%\ub{<procedure:*>}% %\ub3% (- 5 8)))
(%\ub{<procedure:/>}% %\ub3% (%\ub{<procedure:*>}% %\ub3% (%\ub{<procedure:->}% %\ub5% 8)))
(%\ub{<procedure:/>}% %\ub3% (%\ub{<procedure:*>}% %\ub3% (%\ub{<procedure:->}% %\ub5% %\ub8%)))
(%\ub{<procedure:/>}% %\ub3% (%\ub{<procedure:*>}% %\ub{3}% %\ub{-3}%))
(%\ub{<procedure:/>}% %\ub3% %\ub{-9}%)
%\ub{-1/3}%
\end{SchemeCode}

После того, как оказались вычислены все элементы самого внешнего списка, мы смогли, наконец, получить результат.

Вычисление функций производится согласно \index{подстановочная модель вычислений}\emph{подстановочной модели}, согласно которой передаваемые аргументы подставляются вместо формальных аргументов в~тело функции. Проиллюстрируем этот принцип на~примере вычисления следующей \s{lambda}\=/функции:
\begin{SchemeCode}[emph=x]
((lambda (x) (+ x (* 2 x ))) 3)
\end{SchemeCode}
Формальным аргументом этой функции является символ \lex{x}. Если мы в~теле функции заменим этот символ на~переданный аргумент \s{3}, то получим выражение:
\begin{SchemeCode}
(+ 3  (* 2 3))
\end{SchemeCode}
которое уже может быть вычислено.

Все без~исключения функции в~\Scheme вычисляются в~рамках подстановочной модели и~в аппликативном порядке. Нарушают этот порядок \index{специальная форма}\emph{специальные формы}, которые функциями не~являются, хоть и~имеют сходный с~ними синтаксис. Мы уже встречали специальные формы: \s{define}, \s{lambda} и~\s{if}~--- они действуют, не~вычисляя предварительно все свои аргументы.

\begin{Assignment}%
\label{Ass:dup}
Напишите определение функции \s{(dup f)}, которая удваивает применение переданной ей функции \s{f}: \s[emph={f,x}]{((dup f) x) ==> (f (f x))}

% \fnindex{dup@Scheme@прочие функции}
\begin{Specification}[emph=x]
(test 
  ((dup sqr) 2)        ==> 16
  ((dup add1) 2)       ==> 4
  ((dup (dup sqr)) 2)  ==> 65536
  (((dup dup) sqr) 2)  ==> 65536)
\end{Specification}

Объясните, используя подстановочную модель, как вычисляются тестовые примеры.
\end{Assignment}


\section[2]{Тип функции}%
\index{тип!функции}%
Функции, как полноправные объекты языка, также имеют тип, он называется \index{сигнатура функции} \emph{сигнатурой функции}. Сигнатура определяет область определения функции и область её значений.

Они записываются в следующей форме:

\medskip
\begin{tabular}{r@{\ --\ }>{\TextComment}p{8cm}}
   \Type{A \arrow B} & функция одного аргумента, имеющего тип \Type{A}, и возвращающая величину типа \Type{B};\\
   \Type{A B \arrow C} & функция двух аргументов;\\
   \Type{A .. \arrow B} & функция произвольного числа аргументов.
\end{tabular}
\medskip

Это обозначение сигнатуры соответствует представлению о функции, как об отображении множества определения в множество значений.

Приведём пример, указав тип для написанной нами на стр.~\pageref{example:sign}  функции \s{sign}:
\begin{SchemeCode}
(:: sign (Real -> ($\cup$ -1 0 1))
 (define (sign x)
  (cond
    [(negative? x) -1]
    [(zero? x) 0]
    [else 1]))
\end{SchemeCode}
Оисание типа говорит нам, что функция \s{sign} является отображением из~множества действительных чисел во~множество, состоящее из трёх элементов $\{-1,0,1\}$.

Указывать типы функций и их аргументов не обязательно, однако их использование помогает документировать код, делает его более устойчивым и облегчает отладку программ, чётко локализуя ошибки. Например, если передать функции \s{sign} число, не являющееся действительным, или вообще не число, то будет вызвано сообщение о несоответствии типов функции \s{sign}, определённой именно на на множестве действительных чисел. При отсутствии явного указания типа ошибка <<пройдёт>> внутрь определения функции и сообщение об ошибке вызовут функции \s{negative?} или \s{zero?}, хотя неправильной была именно попытка определить знак у объекта, не имеющего знака.

А как записать сигнатуру функции \s{dup} (Задание \ref{Ass:dup}), принимающую в качестве аргумента функцию и возвращающую функцию? К тому же, если нам заранее неизвестна сигнатура передаваемой функции: обратите внимание, что в тестовых примерах функции \s{dup} передавали сначала числовую функцию, а потом и её саму. 

В таких случаях используется \index{тип!полиморфный} \emph{полиморфный тип} --- представление набора типов как единственного типа. Полиморфный тип обозначается любым свободным символом, например, сигнатура функции \s{dup} может быть записана так:

\begin{SchemeCode}
 (:: dup (A -> A) -> (A -> A)
   ...)
\end{SchemeCode}

Здесь символом \s{A} обозначен \emph{произвольный тип}. Существенным является то, что аргумент функции \s{dup}, имея тип \s{A -> A}, должен принимать и возвращать величины одинакового типа. Это важно для повторного применения функции. Таким образом, и возвращать функция \s{dup} должна функцию с такой же сигнатурой. Конктретный смысл полиморфный тип \s{A} приобретает при применении функции, например для примера \s{(dup sqr)} он интерпретируется, как общечисловой тип \Type{Num}, а в случае \s{(dup dup)} --- как \s{A -> A}.

Хотя в \Lang{Formica}, как и во многих других языках программирования, тип функции указывать не обязательно, типы играют очень важную роль в функциональных языках. Приведём слова математика Хаскелла Карри, одного из~основоположников теории функций: «... доказательством является программа, формулой, которую нужно доказать~--- тип программы». Мощная система абстрактных, алгебраических, полиморфных и~рекурсивных типов вместе в~механизмом вывода типов, делают функциональную парадигму не~уступающей, а~во многом и~превосходящей по~выразительности и~уровню абстракции объектно-ориентированный подход.

\section[4]{Частичное применение функций}%
\index{частичное применение}%
В стандартном \Racket (как и в большинстве языков программирования), если функция, в результате аппликации, получает фактических аргументов меньше, чем определено формальных, вызывается сообщение об ошибке. Однако для функциональных языков возможен и другой вариант: функции можно применять \emph{частично}.

Поясним на примере. Пусть у нас определена простая функция, складывающая два своих аргумента:

\begin{Definition}[emph={x,y}]
  (define (f x y)
    (+ x y))
\end{Definition}
\newpage

Зафиксируем один из её аргументов, скажем, положим $x = 5$. В таком случае, свободным останется всего один аргумент~--- $y$, и мы можем воспринимать получившийся объект, как функцию \s{(lambda (y) (+ 5 y)}. Фиксирование части аргументов функции и называется её \emph{частичным применением}.

В языке \Scheme частичное применение функции, фиксирующее аргументы \emph{слева}, записывается, как вызов функции с частью аргументов. Например, если нормальный вызов функции даёт нам результат:
\REPL{(f 5 3)}{8}
\noindentто частичное применение --- функцию:
\REPL{(f 5)}{#<procedure:curried:f>}
\noindentПолучившаяся унарная функция \s{(f 5)} прибавляет к своему аргументу число 5:
\REPL{((f 5) 3)}{8}

Таким образом, создать функцию, удваивающую свой аргумент, можно тремя способами: через определение, с помощью анонимной функции и частично применив функцию умножения:
\begin{SchemeCode}
  (define (double x) (* 2 x))
  (lambda (x) (* 2 x)))
  (* 2)
\end{SchemeCode}

Подробнее о~частичном применении мы~будем говорить на~Занятии~\ref{Less:high-order}, когда рассмотрим процедуру \emph{каррирования функций}.

Частичное применение используется во многих функциональных языках программирования, например в \Lang{ML}, \Lang{Haskell} и т.п.

\section{Чистота функций и~языка}%
\index{функция!чистая}Математическое понимание функции подразумевает, что для одних и~тех же аргументов, вычисляемая функция всегда возвращает одни и~те же результаты. Иными словами, результат функции зависит только от~переданных ей параметров. Функции, обладающие такими свойствами, называются \emph{чистыми}.

Использование чистых функций даёт ряд существенных преимуществ. Перечислим некоторые из~них:

\begin{itemize}[--]
 \item \emph{Надёжность и~корректность.} Для чистых функций работает простая подстановочная модель вычислений. Пользуясь подстановочной моделью, можно с~математической точностью показать, как будет работать программа и~какими свойствами она будет обладать.

 \item \emph{Модульность.} Чистые функции позволяют разбивать функциональные программы на~отдельные совершенно независимые части. Эти части легко отлаживать по~отдельности, их можно выполнять в~произвольном порядке или параллельно.

 \item\label{memo1}\index{мемоизация}\emph{Прозрачность по~ссылкам.} При~использовании чистых функций можно запоминать возвращаемые ими результаты, и~при повторном вызове функции с~теми же аргументами, использовать уже посчитанные значения. Этот приём называется \emph{мемоизацией}.
\end{itemize}

Что может помешать функции быть чистой? В~первую очередь, зависимость результата от~глобальных внешних параметров, которые могут быть изменены другими функциями. Последние, в~таком случае, называются \index{функция!разрушающая}\emph{разрушающими}, а~их влияние на~глобальные параметры~--- \index{побочный эффект}\emph{побочным эффектом}.

Основными источниками побочных эффектов являются процедуры ввода-вывода и~\emph{операция присваивания}, позволяющая изменять значение переменной. В~то время, как без~ввода-вывода обойтись невозможно, от~присваивания можно избавиться полностью, заменив его передачей значений функциям и~\emph{связыванием} символов со~значениями.

Отличие связывания от~присваивания состоит в~том, что в~результате связывания мы получаем \emph{неизменяемые данные}. В~рамках подстановочной модели, мы не~просто в~состоянии заменить все символы теми значениями, с~которыми они связаны, но мы можем сделать это \emph{в любой момент исполнения программы}, не~изменяя результата её работы.

В большинстве функциональных языков, присваивание используется очень ограниченно и~только в~тех случаях, когда это даёт существенный выигрыш в~эффективности. А~в \index{языки программирования!чистые}\emph{чистых функциональных языках} (таких, как \Lang{Haskell}) его нет вовсе.

\Scheme не~является чистым языком, но в~нём очень чётко разделяются данные, неизменяемые и~изменяемые с~помощью присваивания, и~в наших силах полностью избежать использования разрушающих функций. Поэтому рассматривать изменяемые данные в~этом курсе мы не~будем. Всюду вместо присваивания мы будем использовать связывания с~помощью определений или лексического замыкания.

Таким образом, мы везде, где это возможно, будем действовать в~рамках чистого функционального программирования.

\index{лексическое замыкание}
\section{Лексическое замыкание}%
В определениях функций, символы, обозначающие аргументы, \emph{лексически замыкаются}. То есть, любое ранее определённое связывание для символа не используется, если символ выступает в~роли формального аргумента функции.

Таким образом, в~примере на~стр.\,\pageref{define}, определение, связывающее символ \s{a} со~значением 2, не~помешало использовать этот же символ в~качестве аргумента функции \s{sqr}.

Определения могут даваться внутри других определений. При~этом внутренние определения так же оказываются лексически замкнуты:

\begin{SchemeCode}[emph={x,r}]
   > (define (disc-area r)
       (define (sqr x) (* x x))
       (* pi (sqr r)))
\end{SchemeCode}
\REPL
  {(disc-area 4)}
  {50.26548245743669}

Внутренние определения бывают нужны тогда, когда возникает необходимость оптимизировать вычисления, разбивая задачу на~подзадачи. Например, выражение $(x + y)^2- 4x(x + y)-y(x + y)$, можно посчитать, как $z^2-4xz-yz$, где $z = x + y$. Это можно сделать с~помощью внутреннего определения \s{define}, а~можно и~по-другому, с~помощью анонимной функции:

\begin{Definition}[emph={x,y,z}]
(define (f x y)
  ((lambda (z) (- (* z z) (* 4 x z) (* y z)))
   (+ x y)))
\end{Definition}

Согласно подстановочной модели вычислений, сначала будет вычислена сумма \s[emph={x,y}]{(+ x y)}, а~потом на~неё будет заменён символ \lex{z} в~теле \lmфункции. Обратите внимание на~то, что величины \lex{x} и~\lex{y} используются, как внутри \lmфункции, так и~за её пределами. Они имеют глобальную область видимости в~пределах определения функции \s{f}. Символ \lex{z} имеет область видимости только в~теле \lmфункции.

Необходимость введения таких локальных переменных, как \lex{z}, случается достаточно часто. Для этих целей в~\Scheme существует специальная форма \sfi{let}:

\begin{Definition}[emph={x,y,z}]
(define (f x y)
  (let ([z (+ x y)])
    (- (* z z) (* 4 x z) (* y z))))
\end{Definition}

Эта форма, работает точно так же, как и~\lmфункция~--- сначала она вычисляет значение локального символа, а~потом подставляет его в~конечное выражение.

В общем случае, синтаксис формы \s{let}, задающей несколько локальных символов \s{var1}, \s{var2}, ... для вычисления выражения \s{expr}, следующий:
\begin{SchemeCode}
(let ([var1 body1]
      [var2 body2] ...)
  expr)
\end{SchemeCode}


\begin{Assignment}

Одной из~важных задач прикладной математики является задача численного интегрирования функции. Существует простой и~эффективный метод интегрирования, годный для полиномов и~для достаточно гладких функций:\footnote{Приведённый метод называется методом Гауссовых квадратур третьего порядка, он даёт точные значения интеграла для полиномов до~5-й степени.}
$$\int\limits_a^b f(x) dx \approx \frac{b-a}2\left[ \frac59 g\left(-\sqrt{3/5}\right)+\frac89g(0)+\frac59g\left(\sqrt{3/5}\right)\right],$$ где $$g(x)=f\left(\frac{a+b}2+\frac{b-a}2x\right).$$

Напишите функцию \fun{integrate}{f a b}, которая вычисляла бы интеграл от~функции \lex{f} в~интервале от~\lex{a} до~\lex{b}, используя описанный метод.

Проверьте правильность работы функции на следующих примерах:
$$\int\limits_1^4 x^2 dx,\quad \int\limits_0^3 (x^5-x) dx,\quad \int\limits_0^2 \sin x\,dx.$$

Библиотека \s{plot} предоставляет возможность построить график заданной функции $f$ в пределах от $x_1$ до $x_2$ следующим образом:
\begin{SchemeCode}
  (plot (function $f$ $x_1$ $x_2$))
\end{SchemeCode}
Постройте на отрезке $(-2\pi, 2\pi)$ график интегрального синуса: $$\int\frac{\sin x}{x} dx.$$ 

\end{Assignment}

\begin{Queeze}
  \item Какие свойства функций делают языки программирования функциональными?
  \item Что такое анонимная функция? Какую роль она играет в~функциональном программировании? Приведите примеры её применения и~создания в~\Scheme.
  \item Опишите аппликативный порядок и~подстановочную модель вычислений. Чем отличаются строгие и~нестрогие языки программирования?
  \item Какие функции называются чистыми? В~чём заключается преимущество использования чистых функций?
  \item Что такое лексическое замыкание? Для чего оно может использоваться? Как его осуществить в~языке \Scheme?
\end{Queeze}


