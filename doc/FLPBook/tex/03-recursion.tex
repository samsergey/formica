%!TEX root = main.tex
% revision done
\Lesson{Рекурсия}\label{Less:recursion}

% \begin{Abstract}
%   На этом занятии рассматриваются
% \end{Abstract}


\section{Зачем нужна рекурсия?}\index{рекурсия}%
Мы уже говорили, что решив использовать только чистые функции, мы отказываемся от~использования изменяемых данных и~операции присваивания. Как же в~таком случае реализовать циклические процессы с~изменяемыми параметрами, такие, как условный цикл \pcc{while} или итеративный \pcc{for}? В~функциональной парадигме для этого используется \emph{рекурсивный вызов}, или \emph{рекурсия}~--- вызов функции из~её собственного тела.

Пусть нам нужно найти сумму квадратов целых чисел от~1 до~$N$. В~большинстве императивных языков программирования мы организовали бы цикл, в~котором некая переменная пробегала бы по~заданному диапазону, и~искомая сумма вычислялась, например, по~следующей схеме:

\label{while}
\begin{PseudoCode}[emph={i,sum,N}]
  i := 1
  sum := 0
  while i < N do
    sum := sum + $i^2$
    i := i + 1
  return sum
\end{PseudoCode}

Но что делать, если у нас нет присваиваний, или мы не хотим ими пользоваться? Эту задачу можно решить при~помощи рекурсии. Обратим внимание на~то, что задача вычисления суммы из~$N$ слагаемых сводится к~задаче вычисления суммы из~$N-1$ слагаемого:
\begin{equation*}
1 + 2^2 + 3^2 +... + N^2 = (1 + 2^2 + 3^2 +... + (N-1)^2) + N^2.
\end{equation*}
Исключением является случай $N = 0$. Будем считать, что сумма без~слагаемых всегда равна 0. Таким образом, получаем функциональный рекурсивный алгоритм:\label{sumsq}
\begin{SchemeCode}
  sumsq $0$ $=$ $0$
  sumsq $N$ $=$ $N^2$ $+$ sumsq $(N-1)$
\end{SchemeCode}
Запишем его на~\Scheme

\begin{Definition}[emph=N]
(:: sum-sq (Nat -> Nat)
 (define/. sum-sq
   0 --> 0
   N --> (+ (sqr N) (sum-sq (- N 1)))))
\end{Definition}
и удостоверимся в том, что наша функция работает:

\REPL
  {(sum-sq 2)}
  {5}
\REPL
  {(sum-sq 200)}
  {2686700}
\REPL
  {(sum-sq 0)}
  {0}

В рекурсивном решении вместо изменяемых переменных --- \lex{i} и \lex{sum}, мы использовали меняющийся аргумент \lex{N} и возможность функции передавать этот аргумент самой себе.


\index{рекурсия!база рекурсии}
\section[2]{База рекурсии}%
В теории вычислений важным является вопрос \emph{завершаемости} вычислительного процесса. Для получения результата, цепочка рекурсивных вызовов должна, рано или поздно, прекратиться. Таким образом, рекурсивная функция обязательно должна включать в~себя конструкцию выбора, определяющую условие (одно или несколько) выхода из~рекурсии. Такие условия называют \emph{базой рекурсии}.

В этой связи, становится особенно важным то, что при~использовании строгих вычислений, конструкция выбора не~должна подчиняться аппликативному порядку. Если бы в~определении функции \s{sum-sq} оператор \s{if} был не~специальной формой, а~функцией, то, прежде чем производить выбор той или иной ветви, были бы вычислены обе ветви вычислений, в~том числе и~содержащая рекурсивный вызов.

Позже мы ещё раз коснёмся завершаемости рекурсии, рассматривая структурную рекурсию (см.~стр.\,\pageref{struct-recursion}).

\section[4]{Рекурсивные и~итеративные процессы}\label{iterations}%
На первом этапе вычисления рекурсивной функции процесс строит цепочку отложенных операций и происходит расширение вычисляемого выражения, а на втором этапе эти отложенные операции выполняются и происходит сжатие. Для хранения отложенных вычислений и их результатов используется \emph{стек}~--- структура данных в памяти, работающая по~правилу <<последним вошёл~--- последним вышел>>.

Воспользуемся подстановочной моделью вычисления и~проследим, как действует функция \s{sum-sq} при~вычислении суммы квадратов первых четырёх натуральных чисел.
\begin{SchemeCode}
  (sum-sq 4)                          > 
  (+ (sum-sq 3) 16)                   > %\pccomment Заполнение%
  (+ (+ (sum-sq 2) 9) 16)             > %\pccomment стека%
  (+ (+ (+ (sum-sq 1) 4) 9) 16)       > 
  (+ (+ (+ (+ (sum-sq 0) 1) 4) 9) 16) > %\hrule%
  (+ (+ (+ (+ 0 1) 4) 9) 16)          < 
  (+ (+ (+ 1 4) 9) 16)                < %\pccomment Освобождение%
  (+ (+ 5 9) 16)                      < %\pccomment стека%
  (+ 14 16)                           <
  30
\end{SchemeCode}

Вычислительный процесс, который характеризуется цепочкой отложенных операций, называется \index{процесс!рекурсивный}\emph{рекурсивным}.

Реализация итеративного цикла на~регистровой машине более эффективна, чем реализация рекурсии, поскольку итерации не~требуют использования стека для хранения отложенных операций и~вычисление не~имеет двух этапов~--- расширения и~сжатия. По~этой причине, у~рекурсии сложилась «дурная репутация» в~мире императивных языков программирования. В~некоторых руководствах по~программированию рекомендуют, по-возможности, избегать использования рекурсии.

Однако, в~рамках чистого функционального программирования без~рекурсии не~обойтись. Значит ли это, что мы обречены на~неэффективные функциональные программы? Оказывается, можно так построить рекурсивное определение функции, что оно будет эквивалентно итеративному циклу и~по скорости выполнения и~по использованию памяти (стека).

\newpage
Посмотрите на~следующую схему вычислений:
\begin{SchemeCode}
  sumsq $N$ $=$ iter $0$ $1$ 
  iter $S$ $i$ $=$ if $i > N$
             then $S$
             else iter $(S + i^2)$ $(i + 1)$
\end{SchemeCode}
Она соответствует итеративному циклу, показанному на~стр.\,\pageref{while}. Здесь так же, введены две переменные~--- изменяющийся счётчик \lex{i} и~накопитель \lex{S}, но мы обошлись без~присваивания. Инициализация переменных произошла при~первом вызове функции \s{iter}, а~последовательное изменение их значений происходит во~время рекурсивного вызова этой функции.

Вот реализация этих вычислений на~языке \Scheme:

\begin{Definition}[emph={N,S,i}]
(:: sum-sq (Nat -> Nat)
  (define (sum-sq N)
    (define (iter S i)
      (if (> i N)
          S
          (iter (+ S (sqr i)) (+ i 1))))
  (iter 0 1)))
\end{Definition}

Изобразим по~шагам процесс вычисления \s{(sum-sq 4)}, показывая, чему равны текущие значения аргументов функции \s{iter}:

\begin{SchemeCode}[emph={i,S}]
  (sum-sq 4)
  (iter 0 1)               i = 1  S = 0
  (iter (+ 0 1) (+ 1 1))   i = 2  S = 1
  (iter (+ 1 4) (+ 2 1))   i = 3  S = 5
  (iter (+ 5 9) (+ 3 1))   i = 4  S = 14
  (iter (+ 14 16) (+ 4 1)) i = 5  S = 30
  30
\end{SchemeCode}
При $i = 5$ срабатывает условие $i > N$, и~возвращается текущее значение аккумулятора \lex{S}.

Рассмотренный нами процесс не~растёт и~не сжимается. На~каждом шаге при~любом значении \lex{N} необходимо помнить лишь текущие значения переменных \lex{i} и~\lex{S}. Такой процесс называется \index{процесс!итеративный}\emph{итеративным}, в~нём решение задачи \emph{заменяется} решением другой задачи.

Посмотрим, чем отличаются рекурсивное и~итеративное определения. В~рекурсивном определении вызов функции \s{sum-sq} является аргументом функции \s{+}. В~итеративном определении наоборот, результат сложения передаётся функции \s{iter}. Таким образом, хотя функция \s{iter} и~вызывает рекурсивно саму себя, но делает это в~последнюю очередь, как говорят, \emph{в хвостовой позиции}\footnote{Обратите внимание на~то, что итеративная функция \s{sum-sq} так же вызывает функцию \s{iter} в~хвостовой позиции, полностью передавая ей управление вычислительным процессом.}, поэтому нет необходимости запоминать на~стеке связывания для переменных текущего уровня вложенности. Подобный вид рекурсии примечателен тем, что может быть легко заменён на~итерацию, и~называется \emph{хвостовой рекурсией}.

Таким образом, мы можем дать более или менее общие схемы построения функций, порождающих рекурсивный и~итеративный процессы:
\begin{center}
\noindent
\begin{tabular}{ll}
\pccomment рекурсивный процесс & \pccomment итеративный процесс\\
 \begin{minipage}{0.4\textwidth}
\begin{SchemeCode}
f(...) = 
  if $base$-$test$
  then $base$-$result$ 
  else $g(..., f(...), ...)$
\end{SchemeCode}
\end{minipage}&
\begin{minipage}{0.4\textwidth}
\begin{SchemeCode}
f(...) = 
  if $base$-$test$
  then $base$-$result$ 
  else $f(..., g(...), ...)$
\end{SchemeCode}
\end{minipage}
\end{tabular}
\end{center}


Компиляторы многих функциональных языков программирования (и \Scheme в~том числе) способны распознавать хвостовую рекурсию и~транслировать их в~эффективный машинный код, реализующий простой итеративный цикл.

И последнее замечание. Если мы в~императивной программе, использующей цикл \pcc{while}, показанной на~стр.\,\pageref{while}, поменяем порядок присваиваний внутри цикла, результат поменяется. В~функциональном решении изменение всех переменных происходит одновременно~--- в~момент рекурсивного вызова. Это является следствием использования чистых функций.

\section[3]{Синтаксис для рекурсивных циклов}\label{named-let}%
Так как циклы встречаются в программировании повсюду, для удобства написания рекурсивных программ в \Scheme определена форма \s{let}, позволяющая обходиться без внутреннего \s{define}:

\begin{tabular}{cp{0.1\linewidth}c}
  \begin{minipage}{0.35\linewidth}
\begin{SchemeCode}[emph={name,x,y,x0,y0}]
(define (f args ...)
  (let name ([x x0] 
             [y y0] ...)
    body ...))
\end{SchemeCode}    
  \end{minipage} & эквива\-лентно &
  \begin{minipage}{0.35\linewidth}
\begin{SchemeCode}[emph={name,x,y,x0,y0}]
(define (f args ...)
  (define (name x y ...)
    body ...
  (name x0 y0 ...))
\end{SchemeCode}    
  \end{minipage}
\end{tabular}

В обоих случаях рекурсивный вызов в теле \s{body} производится по заданному имени \lex{name}.
Таким образом, определение функции \s{sum-sq}, реализующее итеративный процесс, можно переписать так:
\begin{Definition}[emph={N,S,i}]
(:: sum-sq (Nat -> Nat)
 (define (sum-sq N)
   (let iter ([S 0] [i 0])
     (if (> i N)
         S
         (iter (+ S (sqr i)) (+ i 1))))))
\end{Definition}

\begin{Assignment}

a) Напишите функцию \fun{sum}{f a b}, возвращающую сумму значений произвольной функции \lex{f} в~целых числах от~\lex{a} до~\lex{b}, реализуя рекурсивный и~итеративный процессы:
\begin{Specification}
  (test 
    (sum sqr 1 3)   ==> 4    ; $1^2 + 2^2 + 3^2$
    (sum (+ 1) 2 4) ==> 12   ; $(2+1) + (3+1) + (4+1)$
    (sum sqr 3 3)   ==> 9    ; $3^2$
    (sum sqr 3 1)   ==> 0
    (sum sqr 0.5 3) ==> 8.75)
\end{Specification}
С её помощью, вычислите сумму квадратов чётных чисел от~1 до~100.

\smallskip
б) \label{accumulate}Напишите обобщённую итеративную функцию \fun{accumulate}{g x0 f a b}, такую, чтобы функцию \s{sum} можно было бы выразить через неё, как \s{(accumulate + 0 $f$ $a$ $b$)}. 
\begin{Specification}
  (test         
    (accumulate + 0 sqr 1 3) ==> 14  ; $0 + 1^2 +2^2 + 3^2$
    (accumulate + 0 sqr 3 3) ==> 9   ; $0 + 3^2$
    (accumulate + 0 sqr 3 1) ==> 0)  ; $0 + 0$
\end{Specification}

в) \label{ass:exp} Напишите при~помощи \s{accumulate} функцию, вычисляющую факториал натурального числа. Найдите значение числа $$e = 1 + 1/1! + 1/2! + 1/3! +...$$ с~точностью до~15 знаков после запятой.

\end{Assignment}

\index{трассировка функции}
\section{Трассировка вызовов функции}%
В \Scheme есть инструмент, помогающий в~отладке рекурсивных процедур~--- трассировка вызовов функций. Для её использования нужно загрузить библиотеку \s{racket/trace} с~помощью команды \sfi{require}. После этого, в~программе следует указать, какие функции мы будем отслеживать. Вот пример такой программы:

\begin{Definition}[emph=N]
(require racket/trace)

(:: sum-sq (Nat -> Nat)
  (define/. sum-sq
    0 --> 0
    N --> (+ (sum-sq (- N 1)) (sqr N))))

(trace sum-sq)
\end{Definition}

После того, как мы выполним эти определения, всякий вызов функции \s{sum-sq} будет сопровождаться выводом. При~этом условно (отступами) показывается заполнение и~освобождение стека:

\begin{SchemeCode}
   > (sum-sq 3)
   %\outputstyle>(sum-sq 3)%
   %\outputstyle> (sum-sq 2)%
   %\outputstyle> >(sum-sq 1)%
   %\outputstyle> > (sum-sq 0)%
   %\outputstyle< < 0%
   %\outputstyle< <1%
   %\outputstyle< 5%
   %\outputstyle<14%
   %\outputstyle14%
\end{SchemeCode}

\vspace{-\bigskipamount}
\section[2]{Мемоизация}\index{мемоизация}%
Если мы применим трассировку функции \s{accumulate} во~время вычисления числа $e$ (см. \Asref[в]{ass:exp}), то обнаружим, что эта функция многократно пересчитывает одни и~те же значения. Это делает вычисления крайне неэффективными.

Очень хорошо подобную неприятность иллюстрирует простейший рекурсивный процесс вычисления чисел Фибоначчи, использующий соотношения:
$$
F_1 = 0,\quad
F_2 = 1,\quad
F_n = F_{n-1} + F_{n-2}.
$$
Переведём эти соотношения на~язык \Scheme:

\begin{Definition}[emph=n]
(:: fib  (Nat -> Nat)
  (define fib
    (/. 1 --> 0
        2 --> 1
        n --> (+ (fib (- n 1)) 
                 (fib (- n 2))))))
\end{Definition}

Используя трассировку функции \s{fib}, посмотрите, каким образом вычисляется, например, $F_5$. Вы увидите много избыточных вычислений: вычисление $F_3$ полностью повторяется дважды, а~$F_2$~--- трижды. В~результате, вычисление, например $F_{40}$ превращается уже в~серьёзную проблему. Можно показать, что для вычисления $F_n$ потребуется порядка $1.6^n$ операций.

Когда мы перечисляли преимущества использования чистых функций, мы упоминали возможность заменять многократный вызов функции её результатом, если он уже посчитан. Этот приём называется \emph{мемоизацией} (см.~стр.\,\pageref{memo1}). Если бы мы сохраняли и~использовали промежуточные результаты при~вычислении чисел Фибоначчи, вычислительный процесс соответствовал бы линейной рекурсии, то есть, количество операций, необходимых для вычисления $F_n$ стало бы пропорционально $n$.

В~языке \Scheme определена форма \sfi{define/memo}~--- мемоизирующий аналог формы \s{define} и функция \sbi{memoized}, возвращающая для функции её мемоизированный вариант.

Так определяется мемоизированная функция для вычисления чисел Фибоначчи:
\begin{Definition}
(:: fib  (Nat -> Nat)
  (define/memo fib
    (/. 1 --> 0
        2 --> 1
        n --> (+ (fib (- n 1)) 
                 (fib (- n 2))))))
\end{Definition}

Трассировка этой функции показывает, что каждое из~чисел Фибоначчи теперь вычисляется по~общей схеме только один раз. Повторный вызов функции \s{fib} не~запускает рекурсивный процесс, а~возвращает уже посчитанное значение.

\newpage
\begin{Assignment}

Числа Фибоначчи можно вычислять с~помощью простого итеративного процесса, не~используя память для запоминания промежуточных результатов. Напишите функцию, реализующую этот способ.

Можно ли вычислить произвольное число Фибоначчи вообще не используя никаких циклов за время, не зависящее от номера числа?
\end{Assignment}

\section{Решение уравнений методом бисекции}%
Приведём пример использования рекурсивных функций в~задачах прикладной математики. Рассмотрим способ численного решения алгебраических уравнений методом деления отрезка пополам (бисекции). Математическая постановка задачи такова: для функции $f(x)$ требуется с заданной точностью найти такое $x^*$ чтобы $f(x^*) = 0$.

\label{bisection}Метод бисекции состоит в~последовательном приближении к~искомому корню уравнения $f(x) = 0$ путём последовательного деления пополам отрезка, включающего в~себя корень. Декларативно этот метод можно описать так:

\begin{Algorythm}
  \item Метод определён для отрезка, на котором функция $f$ меняет знак
  \item Если для заданной точности, длину отрезка можно считать малой, корнем считаем середину отрезка.
  \item В противном случае, корень находится либо в правой, либо в левой половине отрезка.
\end{Algorythm}

Запишем «скелет» функции, реализующей метод бисекции:

\newcommand{\cmt}{\normalfont\itshape\color{gray!40!black}}
\fnindex{bisection}
\begin{Definition}[emph={f,a,b}]
(:: bisection ((Real -> Real) Real Real -> ($\cup$ Real #f))
  (define (bisection f a b)
    (and %\cmt функция f меняет знак на~(a b)%
         (let ([c %\cmt среднее между a и~b%])
           (if %\cmt отрезок (a b) достаточно мал%
               c
               (or %\cmt корень на~отрезке (a с)%
                   %\cmt корень на~отрезке (с b)%)))))
\end{Definition}\vspace{-\medskipamount}

\newpage
\begin{Assignment}

Напишите функцию \fun{bisection}{f a b}, так чтобы она находила искомый корень с~точностью до~15-той значащей цифры (с относительной ошибкой $10^{-15}$).

\begin{Specification}
  (test 
    (bisection (lambda(x)(- x 2)) 1 3)          ==> 2
    (bisection (lambda(x)(- x 2000)) 1000 3000) ==> 2000
    (bisection (lambda(x)(+ x 2)) -1 -3)        ==> -2
    (not (bisection (lambda(x)(- x 2)) 0 1))    ;нет корня    
\end{Specification}

Какой процесс, рекурсивный или итеративный, реализует функция \s{bisection}? Решите с~её помощью следующие задачи:

 а) Найдите корень уравнения $\cos x = x^2$.
 
 б) Найдите значение $\sqrt[3]3$ (решите уравнение $x^3 = 3$).

 в) Напишите функцию \s[emph={x}]{(arcsin x)}, вычисляющую арксинус вещественного числа:
\begin{Specification}
  (test 
    (arcsin 0.5)  ==> (asin 0.5)
    (arcsin -1)   ==> (asin -1)
    (arcsin 0)    ==> (asin 0))
\end{Specification}
Здесь мы сравниваем значения нашей функции с системной функцией, вычисляющей арксинус \s{asin}. Определите математически корректную сигнатуру функции \s{arcsin}.

\end{Assignment}

\section{Рекурсия за~преде\-лами~\Scheme}%
Одной из~особенностей \Scheme является то, что процесс вычисления выражений языка рекурсивен: для того, чтобы вычислить выражение, мы должны произвести вычисление всех его элементов по~единой общей схеме (см.~Занятие\,\ref{Less:functions}, стр.\,\pageref{applicative-order}). Эта особенность приводит к~тому, что рекурсивные описания функций и~вычислительных процессов естественны для этого языка. А~если вспомнить, что в~процессе трансляции программ, как правило, используется либо рекурсия, либо заменяющая её итеративная обработка стека, то мы поймём, что рекурсия естественна для чрезвычайно широкого класса задач.

Рекурсивный вызов функции можно использовать практически во~всех современных языках программирования. Непросто даже найти языки, где рекурсия запрещена. Однако не все языки программирования во~время трансляции могут преобразовывать хвостовую рекурсию в~итеративный код. Первым языком, в~котором оптимизация хвостовой рекурсии была реализована в полной мере и введенав~стандарт, является \Lang{Scheme}. Кроме него, оптимизация хвостовой рекурсии присутствует в таких функциональных языках, как \Lang{Haskell}, \Lang{OCaml}, \Lang{Clojure} и т.д.

\begin{Queeze}

  \item Какие функции называются рекурсивными?

  \item Что такое бесконечная рекурсия и~как её избежать?

  \item В~чём отличие рекурсивного и~итеративного процессов? Что такое хвостовая рекурсия?

  \item Как выразить циклы \pcc{while} и~\pcc{for} при~помощи рекурсии?

  \item Почему рекурсия характерна для функционального программирования?

  \item Что такое мемоизация? Каким требованиям должны удовлетворять функции, для того, чтобы можно было использовать их мемоизацию?
\end{Queeze}

