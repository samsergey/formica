%!TEX root = main.tex
\Lesson{Функции высшего~порядка и~функционалы}%
\label{Less:high-order}

\section[4]{Абстракция вычислительного процесса}%
В предыдущих главах мы познакомились с приёмами, хоть и характерными для функционального программирования, но успешно используемыми и вне этого подхода: рекурсия, абстрактные типы данных и символы используются в рамках самых разных парадигм. На этом занятии мы, наконец, займёмся <<настоящим>> функциональным программированием: модифицированием, комбинированием и созданием функций. 

Функциональное программирование подразумевает использование функций, как объектов первого класса, значит их можно передавать в качестве аргументов другим функциям и получать в качестве результатов.
Функция, принимающая в~качестве аргументов другие функции, называется \index{функция!высшего порядка}\emph{функцией высшего порядка}. Если функция возвращает функцию в~качестве результата, то мы будем её называть \index{функционал}\emph{функционалом}, или \index{оператор}\emph{оператором.} 

Мы уже рассматривали и~использовали функции высших порядков: \s{sum}, \s{bisection}, \s{accumulate}, \s{map} и~т.\,п. Некоторые из~них имеют достаточно узкое применение, другие используются очень широко, как универсальные инструменты. Последние являются \index{абстракция!процесса}\emph{абстракциями процессов}, обобщающими некоторые типичные вычислительные процессы. Например, функция \s{accumulate}~--- является абстракцией итерации с~накоплением в~заданном диапазоне числового индекса, \s{map}~--- отображения множества с~помощью заданной функции.

Позже мы рассмотрим ещё несколько полезных и~универсальных абстракций~--- свёртку (абстракцию структурной рекурсии), поиск неподвижной точки (к ней сводится, например, функция \s{bisection} и~вообще, произвольный рекурсивный процесс), монады, как абстракцию последовательных вычислений и~т.\,д.

В то время, как выразительная мощь и~модульность объектно-ориентированного подхода заключается в~абстракции данных, функциональная парадигма достигает этого же абстракцией процедур. Написание и~использование функций высшего порядка делает функциональные программы надёжными, модульными, расширяемыми и, при~правильном подходе, самодокументированными: прозрачными для человека. 
Однако, как и~везде, нужно уметь вовремя остановиться в~повышении уровня абстракции. Программисту необходимо помнить принцип: «Хуже обобщения одного примера может быть только обобщение вообще без~примеров»\footnote{Это один из~принципов, провозглашённых создателями оконной системы X~Windows, используемой в~UNIX-подобных системах и~в Mac OS X.}.


\section[2]{Аппликация}%
\index{аппликация}%
Одной из~самых важных функций высшего порядка является функция \sbi{apply}. Она применяет заданную функцию к последовательности или списку аргументов.

\begin{example}{%
  Примеры применения функции \s{apply}.

  Последний пример показывает, что не все аргументы нужно передавать в виде списка, однако последним аргументом функции \s{apply} должен быть список.}
  \REPLin{(define-formal f)}
  \REPL
    {(apply f '(x))}
    {(f x y)}
  \REPL
    {(apply f '(x y))}
    {(f x y)}
  \REPL
    {(apply f a b '(c))}
    {(f a b c)}
\end{example}

Эту функцию нельзя определить с~помощью других средств языка \Scheme. Процедура \emph{аппликации}, которую она осуществляет, является базовой, наряду с~процедурой \emph{абстракции},\footnote{Здесь имеется ввиду не~абстракция процесса, а~абстракция, как одна из~фундаментальных операций в~исчислении функций. Подробнее см.\,Занятие \ref{Less:lambda-calculus}, стр.\pageref{abstraction}.} реализуемой с~помощью \s{define} и~\s{lambda}.


\section{Каррирование и~сечение~функции}%
Часто бывает нужно многократно применить функцию от нескольких аргументов, при~этом зафиксировав часть из~них. Пусть, например, нам нужно увеличить все элементы списка на~единицу, или сравнить их с~числом. Мы можем решить эти задачи таким образом:

\begin{SchemeCode}
(map (lambda (x) (+ 1 x)) '(1 2 3))
(map (lambda (x) (< x 2)) '(1 2 3))
\end{SchemeCode}

\noindent%
Из бинарных функций \s{+} и~\s{<} мы с~помощью \lmфункций создали унарные функции. Абстракцией этой операции для функций произвольного количества аргументов является \emph{каррирование}.
\index{каррирование}

Функцию нескольких аргументов $f(x, y, z)$ можно представить, как несколько функций одной переменной, <<вложенных>> друг в друга:$$f(x, y, z) = x \mapsto (y \mapsto (z \mapsto f (x, y, z)))$$

Такое представление и~называется \emph{каррированием функции} нескольких переменных. Каррированная функция $f$ своему первому аргументу $x$ ставит в~соответствие функцию от~$y$ и~$z$. Если мы подставим два аргумента $x$ и~$y$, то в~результате получим функцию только от $z$. Подстановка всех трёх аргументов даёт конечный результат. Уменьшение валентности функции засчёт фиксирования некоторых её аргументов называется её \index{сечение}\emph{сечением} или \index{частичное применение}\emph{частичным применением}.

Мы уже встречались с усечёнными и каррированными функциями, когда рассматривали задачу расчёта импеданса электрических цепей. Посмотрите на сигнатуру функции \s{impedance} (стр.~\pageref{example:impedance}): она определена каррированной, для того чтобы для заданной цепи возвращать функцию, вычисляющую импеданс. Функциональное решение также использовало принципы каррирования. Бинарные функции \s{R}, \s{C} и \s{L}, вызываемые с одним аргументом, превращались в сечения --- унарные функции, преобразующие частоту в импеданс.

\label{ML-notation}\index{нотация!бесскобочная}В очень многих функциональных языках программирования все функции каррированы и~это позволяет обходиться без~функциональных скобок при~их применении. В языке \Scheme разрешён упрощённый синтаксис для сечения функций, таким образом, и в нём все функции можно воспринимать, как каррированные.

\begin{Assignment}

  а) Напишите определение для функционала \fun{curry}{f xs \ddd}, который возвращал бы сечение функции \lex{f}, фиксируя аргументы \lex{xs \ddd}. 

  \begin{Specification}
(test
  (map (curry * 2) '(1 2 3)) ==> '(2 4 6)  ;$(2\times1\ 2\times2\ 2\times3)$
  (map (curry - 2) '(1 2 3)) ==> '(1 0 -1) ;$(2-1\ 2-2\ 2-3)$
  ((curry list 1 2) 3 4)     ==> '(1 2 3 4))
  \end{Specification}

  б) Для некоммутативных операций не~всё равно, какой аргумент отбрасывается при~сечении. При использовании функционала \s{curry}, аргументы каррированной функции фиксируются «слева». Напишите функционал \si{curryr}, фиксирующий аргументы «справа»: 

  \begin{Specification}
(test 
  (map (curryr - 2) '(1 2 3)) ==> '(-1 0 1)   ;$(1-2\ 2-2\ 3-2)$   
  (map (curryr < 2) '(1 2 3)) ==> '(#t #f #f)
  ((curryr list 1 2) 3 4)     ==> '(3 4 1 2))  
  \end{Specification}
\end{Assignment}

\section{Композиция функций}%
\index{композиция функций}%
\emph{Композицией} называется такая комбинация двух функций, что результат одной из них подставляется в~качестве аргумента другой. Математически это записывается так:$$(f \circ g)(x) = f(g(x))$$
Композиция является \emph{абстракцией комбинирования функций}: с~её помощью мы можем порождать новые функции не~используя явных связываний и~формальных аргументов.

В языках \Scheme и \Lang{Haskell} функции каррированы, это позволяет обобщить понятие композиции  для функций нескольких переменных. Рассмотрим, например, как можно свести к композиции следующее выражение, записанное в префиксной нотации:
$$(f~(g~x)~y).$$
Если считать бинарную функцию $f$ каррированной, то выражение можно переписать так:
$$((f~(g~x))~y),$$
при этом к аргументу \lex{y} применяется функция $(f~(g~x))$, которую можно представить, как: $((f\circ g)~x)$, опять же, при условии, что и функция $f$ и композиция каррированы. Таким образом, исходное выражение переписывается следующим образом: $$(((f \circ g)~x)~y) = ((f \circ g)~x~y).$$

\newpage
\begin{Assignment}
a) Определите функцию \s{compose}, возвращающую композицию произвольного числа унарных функций:
\begin{Specification}
(test
  ((compose sqr +) 1 2 3)           ==> 36
  ((compose list list sqr +) 1 2 3) ==> '((36))
  ((compose +) 1 2 3)               ==> 6)
\end{Specification}

б) Оператор композиции функций должен удовлетворять следующим свойствам:
\begin{itemize}
  \item \emph{ассоциативность}: $(f \circ g) \circ h = f \circ (g \circ h)$,
  \item \emph{наличие нейтрального элемента}: $f \circ id = id \circ f = f$.
\end{itemize}
Здесь \s{id} --- тождественная функция.
Проверьте, удовлетворяют ли этим свойствам написанный вами вариант оператора \s{compose} и обобщённая композиция $\circ$\footnote{Символ $\circ$ может быть введён, как \s{\\circ} + \MenuItem{Alt} \s{\\}}. Рассмотрите  композицию функций различной валентности.
\end{Assignment}


\section{Некоторые полезные функционалы}\label{operators}%
В арсенале функционального программирования существует много полезных операторов и функционалов, позволяющих комбинировать и модифицировать функции. В примерах к этому разделу будут использоваться формальные функции \s{f} и \s{g}.

\medskip
\fun{const}{C}~--- тождественная функция, возвращающая значение константы \lex{C} для любых аргументов.

\REPL
  {((const 5) 1 2)}
  {5}

% \REPL
%   {(map (const 'a) '(2 9 0))}
%   {(a a a)}

\medskip
\fun{arg}{n}~--- тривиальная функция, возвращающая \lex{n}-ный переданный ей аргумент.
\REPL
  {((arg 2) 'x 'y 'z)}
  {y}

Через функцию \s{arg} выражаются два часто встречающиеся оператора \si{I1} и \si{I2}:
\begin{SchemeCode}
  I1 = (arg 1),   I2 = (arg 2).
\end{SchemeCode}

\medskip
\fun{flipped}{f} -- возвращает функцию, эквивалентную $f$, но принимающую аргументы в обратном порядке.
\REPL
  {((flip f) 1 2)}
  {'(f 2 1)}

\medskip
\fun{fif}{test? f g}~--- оператор выбора функции по~функции\=/предикату. Все функции\=/аргументы этого оператора получают одинаковые аргументы.
\REPL
 {(map (fif even? f g) '(1 8 13 4))}
 {'((g 1) (f 8) (g 13) (f 4))}

\medskip
\fun{andf}{p q \ddd}, \fun{orf}{p q \ddd} и \fun{negated}{p}~--- операторы конъюнкции, дизъюнкции и отрицания предикатов.
\REPL
  {(filter (andf integer? (> 3)) '(2.5 -6 4 2 12))}
  {'(-6 2)}
\REPL
  {(map (negated <) '(1 2 3 4) '(3 3 3 3))}
  {'(#f #f #t #t)}

\medskip
\fun{argmap}{f g} --- оператор, применяющий перед аппликацией функции \lex{f} унарную функцию \lex{g} к её к аргументам.
\REPL
  {((argmap f g) 'x 'y 'z)}
  {'(f (g x) (g y) (g z))}

\begin{Assignment}
Напишите определения для операторов \s{const}, \s{arg}, \s{flipped}, \s{fif}, \s{andf}, \s{orf}, \s{negated} и \s{argmap}. Дайте спецификацию их типа.
\end{Assignment}

\section[2]{Бесточечная нотация}\index{нотация!бесточечная}\label{tacit}%
Часто, при определении функции нет необходимости описывать, как она действует на~свои формальные аргументы. Вместо этого можно дать определение её действию в~целом.

Например, давая определение предикату \si{atom?}, который проверяет, является ли объект элементарным или составным, мы можем написать прямое определение:

\begin{SchemeCode}[emph=x]
(define (atom? x) 
  (not (pair? x)))
\end{SchemeCode}
\noindent или определение, использующее оператор \s{negated}:
\begin{SchemeCode}[emph=x]
(define (atom? x) 
  ((negated pair?) x))
\end{SchemeCode}
\noindent при~этом мы видим, что формальный аргумент \lex{x} никакой информации этому определению не~добавляет и~его можно опустить:
\vspace{-\bigskipamount}
\begin{SchemeCode}
(define atom? (negated pair?))
\end{SchemeCode}
\noindent Это пример определения, записанного в~\emph{бесточечной нотации}.

\label{union}Приведём ещё один простой пример. Посмотрите на~определение функции, возвращающей объединение двух множеств, представленных списками:
\begin{SchemeCode}[emph={s1,s2}]
(define (union s1 s2)
  (remove-duplicates (append s1 s2)))
\end{SchemeCode}
\noindent Видно, что мы передаём аргументы сначала функции \s{append}, которая объединяет два списка-множества в~один, а~потом результат передаём функции \s{remove-duplicates}. Она, в~свою очередь, выделяет множество элементов этого списка, удаляя дубликаты. Поток данных можно схематически показать так:
\begin{center}
\s{s1, s2  $\longrightarrow$  append  $\longrightarrow$  remove-duplicates}
\end{center}

\noindent С~точки зрения функционального программирования, мы имеем композицию функций \s{append} и~\s{remove-duplicates}. Следовательно, мы можем дать следующее определение операции объединения:

\begin{SchemeCode}
(define union ($\circ$ remove-duplicates append))
\end{SchemeCode}

Это именно определение функции, поскольку композиция является функцией, но указывать её формальные аргументы не~требуется. Более того, нам даже не~нужно указывать их количество, поскольку функция \s{append} обрабатывает любое число аргументов, наша функция \s{union} будет обладать таким же свойством!

\begin{example}{Функция \s{union} может работать с~любым количеством аргументов.

Попробуйте вызвать её с~одним аргументом или вовсе без~них.}
\REPL
  {(union '(1 2 3) '(2 3 4))}
  {(1 2 3 4)}

\REPL
  {(union '(a b c) '(1) '(b))}
  {(a b c 1)} 
\end{example}

Важную роль в бесточечном определении функций играет каррирование. Например, имея функцию \s{accumulate} (стр. \pageref{accumulate}), мы можем определить функцию \s{sumf}, вычисляющую $\sum_{i=a}^b f(i)$,  следующим образом:
\begin{SchemeCode}[emph={f,a,b}]
  (define (sumf f a b) (accumulate + 0 f a b))
\end{SchemeCode}
или с помощью сечения:
\begin{SchemeCode}
  (define sumf (accumulate + 0))
\end{SchemeCode}
При этом имеется в виду, что свободные аргументы \lex{f a b} становятся аргументами функции \s{sumf}. Это лаконичное определение очень точно отражает суть определяемой функции: сумма -- это аккумуляция с операцией сложения и нулём в качестве нейтрального элемента.

Так можно определить функцию, вычисляющую $\sum_{i=a}^b i^2$. Зафиксировав первый аргумент функции \s{sumf}, мы оставляем пределы суммирования свободными.
\begin{SchemeCode}
   > (define sumsq (sumf sqr))
\end{SchemeCode}
\REPL
  {(sumsq 1 3)}
  {14} 

В языке \Scheme для определений функций с использованием каррирования служит форма \sfi{define/c}:\label{define-c} 
\begin{SchemeCode}
(define/c (f x y ...) body).
\end{SchemeCode}
Выражение \s{(f x y ...)} представляет собой сечение определяемой функции \s{f}. При этом, если выражение \s{body} возвращает функцию, то её формальные аргументы становятся свободными аргументами функции \s{f}.

Вот, как с помощью формы \s{define/c}, можно определить функцию \s{map}:
\begin{SchemeCode}[emph={f,h,t}]
(define/c (map f)
  (/. '() --> '()
      (cons h t) --> (cons (f h) (map f t))))
\end{SchemeCode}
В заголовке этого определения мы зафиксировали первый аргумент функции \s{map}, оставив свободными аргументы функции, заданной подстановкой. Так как подстановка является унарной, то в результате, мы получаем бинарную функцию:
\REPL
  {(map sqr '(1 2 3))}
  {(1 4 9)} 

Бесточечная нотация делает функциональные программы более декларативными. Вместо описания функции, как последовательности действий над~аргументами, она описывает, чем является эта функция по~отношению к~другим функциям.

Бесточечный стиль характерен для функциональных языков и~широко используется в~языках семейства \Lang{ML}. Однако нужно уметь «вовремя остановиться», используя его. Основная цель такой записи~--- повысить понятность кода и~его надёжность. Однако, используя бесточечный стиль, очень легко превратить программу в~бессмысленный, на~первый взгляд, набор функций и~комбинаторов. Рекомендуется применять бесточечную запись только тогда, когда она чётко и~ясно отражает структуру определяемой функции, приближая определение к~словесному описанию.

\section[4]{Функции высшего~порядка \mbox{за~пределами~\Scheme}}%
Функции высшего порядка можно создавать и~использовать во~всех языках, которые позволяют передавать качестве аргументов функций другие функции или указатели на~них.
Во всех функциональных языках функции~--- объекты первого класса и~создание функций высшего порядка для них естественно.

В языке \Lang{С++} можно создавать такие функции с~помощью указателей на~функции. В~языке \Lang{Pascal} (\Lang{Delphi}) и~прочих объектно-ориентированных языках можно передавать функцию, как метод объекта.

\index{замыкание}Важным инструментом для создания функций высшего порядка является механизм замыкания, который позволил нам описать каррирование функций. Замыкание присутствует во~многих языках: \Lang{С++} использует для этого функторы или блоки; \Lang{Delphi}, \Lang{Perl}, \Lang{Python} и~\Lang{JavaScript}~--- анонимные функции, \Lang{Java}~--- использует анонимные классы внутри методов.

\begin{Queeze}

\item Какая функция называется функцией высшего порядка? Приведите примеры.

 \item Какую роль играют функции высшего порядка и~функционалы в~программировании?

 \item Абстракцией какого процесса является оператор \s{fif}?

 \item Какие функции являются абстракциями комбинирования функций, аппликации функций, частичного применения, рекурсивного обхода древообразной структуры?

 \item Что такое бесточечная нотация?

\end{Queeze}