%!TEX root = main.tex
\Lesson{Составные структуры данных}\label{Less:lists}

\section[2]{Абстракция данных}%
Мы рассмотрели числовые и~логические данные, но их одних недостаточно для эффективного решения разнообразных встающих перед программистами задач. В~большинстве современных языков программирования существуют разнообразные \emph{составные данные}: массивы, структуры, объекты и~т.\,п. Их использование делает возможной \index{абстракция!данных}\emph{абстракцию данных}. Абстракция данных~--- это методология, которая позволяет отделить способ использования составного объекта данных от~деталей того, как он составлен из~элементарных данных.


\section[2]{Точечные пары}\label{pair}%
\index{пара (точечная)}Во многих функциональных языках программирования в~качестве базового инструмента для конструирования составных данных используется \emph{пара}. В~\Scheme пары называются \emph{точечными парами} или \emph{cons\=/ячейками}. Нам они потребуются для самых разнообразных целей, как универсальный контейнер, позволяющий группировать данные.

Для работы с парами используются конструктор пары и функции\=/селекторы.

\begin{example}{%
Конструктором пары является функция \sbi{cons}. Интерпретатор выводит результат в~виде точечной пары: \s{(expr1 . expr2)}.}
\REPL
  {(cons 1 2)}
  {(1 . 2)}
\end{example}

\vspace{-\medskipamount}
\begin{example}{%
Для доступа к~элементам пары используются функции\=/селекторы \sbi{car} и \sbi{cdr}, возвращающие первый и второй элемент пары.}
\REPL
  {(car (cons 1 2))}
  {1}
\REPL
  {(cdr (cons 1 2))}
  {2}
\end{example}

\vspace{-\medskipamount}
\begin{example}{%
Пары могут быть вложенными.}
\REPL
  {(cons (cons 1 2) 3)}
  {((1 . 2) . 3)}
\end{example}

\begin{example}{%
Вложенные справа пары образуют списочную структуру.}
\REPL
  {(cons 1 (cons 2 3))}
  {(1 2 . 3)}
\end{example}

Тип для пар определяется с помощью предиката \sbi{pair?} или дескриптора \s{cons:}.

\begin{example}{%
Предикат \s{pair?} определяет, является выражение парой или атомом.}
\REPL
  {(is (cons 1 2) pair?)}
  {\#t}
\REPL
  {(is 1 pair?)}
  {\#f}
\end{example}

\begin{example}{%
Дескриптор пары \fun{cons:}{A B} определяет пару элементов имеющих типы \lex{A} и~\lex{B}.}
\begin{ExampleCode}
> (is (cons 1 2) 
      (cons: Num Num))
\end{ExampleCode}
\REPLout{\#t}
\begin{ExampleCode}
> (is (cons 1 (cons 2 3)) 
      (cons: Num pair?))
\end{ExampleCode}
\REPLout{\#t}
\end{example}
 
Функция-конструктор \s{cons} не выполняет никаких действий над своими аргументами, она является только контейнером, получить доступ к элементам контейнера можно с помощью функций-селекторов. При этом как именно реализовано хранение и извлечение данных на поведении этих функций не отражается. Типы данных, определяемые подобными конструкторами, называются \emph{абстрактными типами}\index{тип!абстрактный}. Они широко используются в программировании и особенно часто встречаются в функциональном программировании, поскольку отсутствие побочных эффектов гарантирует независимость свойств абстрактных типов данных от их конкретной реализации.

\section[2]{Списки}%
\index{список}%
Когда мы обсуждали синтаксис выражений \Scheme, мы говорили, что выражение может быть либо атомом, либо списком. Теперь мы готовы дать строгое определение списку.

Списком является или \emph{пустой список}\index{пустой список} \sbi{null} или \emph{пара}, второй элемент которой является списком. 

Таким образом, для того чтобы списочная структура стала списком, необходимо, чтобы самая последняя из~вложенных пар имела вторым элементом пустой список. Для конструирования списков используется функция \si{list}~--- её аргументы и~являются содержимым списка.

\newpage
Например, списками будут являться:

\smallskip
\noindent
\begin{tabular}{rl>{\comment}p{2.5cm}}

\begin{ExampleCode}
 null
\end{ExampleCode}& 
\begin{ExampleCode}
= (list)
\end{ExampleCode}& пустой список\\
\begin{ExampleCode}
 (cons 1 null)
\end{ExampleCode}&
\begin{ExampleCode}
= (list 1)
\end{ExampleCode}& список из одного элемента\\
\begin{ExampleCode}
 (cons 1 (cons 2 null))
\end{ExampleCode}&
\begin{ExampleCode}
= (list 1 2)
\end{ExampleCode}& список из двух элементов\\
\begin{ExampleCode}
 (cons (cons 1 2) 
       (cons (cons 2 3)
             null))
\end{ExampleCode} &
\begin{ExampleCode}
= (list (cons 1 2) 
        (cons 2 3))
\end{ExampleCode} & список из двух элементов-пар
\end{tabular}

Списки можно создавать и~без помощи конструктора, используя кавычку \s{'}\index{Racket!базовые формы!quote@\s{'} (\s{quote})}:

\begin{example}{Сокращённый ввод списков.

Последний пример показывает, как можно ввести матрицу. При~этом кавычка ставится только один раз, снаружи.}
\REPL
  {'(1 2 3)}
  {(1 2 3)}

\REPL
  {'(1)}
  {(1)}

\REPL
  {'((1 2) (3 4))}
  {((1 2) (3 4))}
\end{example}

Фундаментальное отличие ввода списков с~использованием конструктора и~с помощью кавычки заключается в~том, вычисляются ли элементы списка. Напомним, что интерпретатор \Scheme сначала вычисляет аргументы функции, а~потом саму функцию. Конструктор \s{list}~--- это функция, поэтому она создаёт список, предварительно вычислив все его элементы. Кавычка же имеет особый смысл: она оставляет элементы выражения невычисленными. 

Таким образом, если мы хотим ввести список констант, можем смело использовать кавычку. Если же элементы списка ещё нужно вычислить, используем явное обращение к~конструктору \s{list}.

\begin{example}{Разница между использованием \s{list} и~\s{'} при~создании списков.}
\REPL
  {(list (+ 1 2) (* 2 3))}
  {(3 6)}

\REPL
  {'((+ 1 2) (* 2 3))}
  {((+ 1 2) (* 2 3))}
\end{example}

\begin{example}{Так как кавычка оставляет выражение невычисленным, с~её помощью мы можем вводить списки символов, не~определяя их значений.}
\REPLin
  {(list a b c)}

{\errorstyle reference to an identifier before its definition: a}

\REPL
  {'(a b c)}
  {(a b c)}
\end{example}

Тип для списков определяется предикатом \si{list?} и дескриптором \s{list:}.

\begin{example}{Предикат \s{list?} определяет, является ли объект списком.}
\REPL{(list? '(1 2))}{#t}
\REPL{(list? (cons 1 null))}{#t}
\REPL{(list? (cons 1 2))}{#f}
\end{example}

\begin{example}{Дескриптор \fun{list:}{A B ...} определяет тип для списка, элементы которого принадлежат, соответственно, к типам \lex{A}, \lex{B} и т.д. Если тип указан таким образом: \s{(list: A ..)} то определяется тип для списка все элементы которого имеют тип \lex{A}.}
\begin{ExampleCode}
> (is '(1 2) 
      (list: Int Int))
\end{ExampleCode}
\REPLout{#t}
\begin{ExampleCode}
> (is '(7 4) 
      (list: odd? 4))
\end{ExampleCode}
\REPLout{#t}
\begin{ExampleCode}
> (is '(1 -4 7 4) 
      (list: Int ..))
\end{ExampleCode}
\REPLout{#t}
\end{example}

\index{пустой список}%
Объект \sbi{null}, обозначающий пустой список, стоит особняком в~ряду используемых типов данных языка \Scheme. Мы говорили, что этот язык работает с атомами, парами или списками, при этом, все списки составляются из пар. Таким образом, можно утверждать, что всякий список является парой. Исключением здесь является символ \s{null}.

\begin{example}{%
Пустой список является списком, но не~является парой.} 
\REPL
  {(list? null)}
  {#t} 

\REPL
  {(pair? null)}
  {#f}
\end{example}

\begin{example}{%
Предикат \s{null?} возвращает \s{\#t}  только для пустого списка.
Предикат \s{empty?} является синонимом \s{null?}. Его используют, когда речь идёт именно о~списке без~элементов.}

\REPL
  {(null? null)}
  {#t}
\REPL
  {(null? 1)}
  {#f}
\REPL
  {(null? (cons 1 2))}
  {#f}
\REPL
  {(empty? null)}
  {#t}
\end{example}

\vspace{-\medskipamount}
\begin{example}{Создать пустой список можно тремя способами.

Чаще всего, мы будем использовать последний.}
\REPL
  {null}
  {()}

\REPL
  {(list)}
  {()}

\REPL
  {'()}
  {()}
\end{example}

В языке \Scheme списки используются в~качестве динамических массивов и~для представления деревьев, их можно так же использовать для работы с~векторами и~матрицами\footnote{В \Scheme существует тип данных \s{vector}, соответствующий индексированному массиву, но в~рамках этого курса мы его рассматривать не~будем.}. Мы будем использовать их, как универсальный контейнер для разнообразных данных.

\section{Структурная рекурсия}%
\label{struct-recursion}%
Обработка списка подразумевает перебор его элементов. В императивных языках, в которых в качестве списка, как правило, применяются массивы, для этого используют цикл по индексу. Время доступа к элементу массива по индексу от индекса не зависит, так что на обработку массива из $N$ элементов требуется $O(N)$ шагов. 
Однако, для односвязных списочных структур, которыми являются списки, чтобы получить $i$-тый элемент списка необходимо совершить $i$ переходов от одного элемента к другому. Так что индексная обработка списка длиной $N$ потребует $O(N^2)$ шагов.

Если требуется обработать все элементы списка по порядку, лишней работы можно избежать. Для этого списки следует обрабатывать так же, как обрабатывается ряд натуральных чисел в процедурах \s{sum} и \s{accumulate}. 

Натуральные числа образуют \emph{индуктивное (рекурсивное) множество}\index{индуктивное множество}, определяемое базовым элементом -- нулём, и функцией следования $S$, которая любому числу ставит в соответствие следующее за ним число: $S(N)=N+1$. 
Таким образом, определение функции \s{sumsq}, данное на стр. \pageref{sumsq}, можно записать так:

\begin{SchemeCode}
  sumsq $0 = 0$
  sumsq $(N + 1) = (N+1)^2$ + sumsq $N$
\end{SchemeCode}

Списки тоже образуют индуктивное множество. Их базовый элемент --- это пустой список \s{null}, а функция следования --- конструктор пары \s{cons}. 
Это означает, что по аналогии с функцией \s{sumsqr} мы можем определить функцию \s{list-sumsqr}, вычисляющую сумму квадратов элементов списка:

\begin{SchemeCode}
  list-sumsq null $=$ $0$
  list-sumsq $($cons $h$ $t)$ $=$ $h^2$ $+$ list-sumsq $t$
\end{SchemeCode}

Для списка \s{lst = (cons $h$ $t$)} его части равны, соответственно, \s{$h$ = (car lst)}, \s{$t$ = (cdr lst)}. Таким образом, получаем рекурсивную программу:

\begin{SchemeCode}
  list-sumsq null $=$ $0$
  list-sumsq $lst$ $=$ $($car $lst)^2$ $+$ list-sumsq $($cdr $lst)$
\end{SchemeCode}
которую можно записать на языке \Scheme:
\begin{SchemeCode}[emph={lst}]
(:: list-sumsqr ((list: Num ..) -> Num)
  (define (list-sumsqr lst)
    (if (null? lst)
        0
        (+ (sqr (car lst)) (list-sumsq (cdr lst))))))
\end{SchemeCode}

\index{рекурсия!структурная}Подобная рекурсивная обработка индуктивных множеств для $N$ элементов потребует $O(N)$ шагов и гарантированно завершится, поскольку индуктивное множество подразумевает наличие базового элемента. Такая рекурсия называется \emph{структурной}.

\index{подстановка}%
Используя подстановки, можно записывать программы для структурно\=/рекурсивных функций, непосредственно следуя их определениям:

\begin{SchemeCode}[emph={N}]
(:: sumsqr (Nat -> Nat)
 (define sumsqr
   (/. 0 --> 0
       (+ 1 N) --> (+ (sqr (+ 1 N)) (sumsqr N)))))
\end{SchemeCode}

\begin{SchemeCode}[emph={h,t}]
(:: list-sumsqr ((list: Num ..) -> Num)
 (define list-sumsqr
   (/. '() --> 0
       (cons h t) --> (+ (sqr h) (list-sumsqr t)))))
\end{SchemeCode}

В этих определениях используется \emph{сопоставление с образцом}, позволяющее распознавать величины абстрактных типов и именовать их части. Подробнее об этой технике мы поговорим на Занятии~\ref{Less:rewriting}. В приведённых нами образцах, символом \lex{N} обозначается число, к которому прибавили единицу, а $h$ и $t$ именуют части абстрактного типа, образованного конструктором \s{cons}.

\newpage
\begin{Assignment}
а) Объясните, какую роль играет явное указание сигнатур функций \s{sumsqr} и \s{list-sumsqr}. Чем грозит отсутствие ограничений, накладываемых сигнатурами?

\medskip
б) Определите сигнатуры и напишите определения для следующих функций:

\s{(make-list $x$ $n$)} --- создаёт список длины $n$ с элементами $x$.

\s{(length $lst$)} --- возвращает длину списка $lst$.

\s{(append $lst_1$ $lst_2$)} --- объединяет списки $lst_1$ и $lst_2$.

\s{(take $lst$ $n$)} --- возвращает первые $n$ элементов списка $lst$.

\s{(any $p$ $lst$)} --- возвращает \s{#t} если в списке $lst$ есть хотя бы один элемент, удовлетворяющий предикату $p$, иначе, возвращает \s{#f}.

\begin{Specification}
(test 
  (make-list 1 3)      ==> '(1 1 1)
  (make-list '(1 2) 3) ==> '((1 2) (1 2) (1 2))
  (make-list 1 0)      ==> '())
\end{Specification}

\begin{Specification}
(test 
  (length '(1 2 3))       ==> 3
  (length '(1))           ==> 1
  (length '())            ==> 0
  (length '((1) 2 (3 4))) ==> 3)
\end{Specification}

\begin{Specification}
(test 
  (append '(1 2 3) '(a b c)) ==>  '(1 2 3 a b c)
  (append '() '(1 2 3))      ==>  '(1 2 3)
  (append '() '())           ==>  '())
\end{Specification}

\begin{Specification}
(test 
  (take '(1 2 3) 2)    ==>  '(1 2)
  (take '(1 2 3) 0)    ==>  '()
  (take '(1 2 3) 4)    ==>  '(1 2 3))
\end{Specification}

\begin{Specification}
(test 
  (any odd? '(1 2 3))
  (not (any odd? '(2 8 4 0)))
  (any list? '(1 (2 3) 4)))
\end{Specification}
\end{Assignment}

\section{Рекурсивные типы данных}%
Натуральные числа и списки образуют индуктивные множества, которые можно описать с помощью индуктивных определений: базы индукции и функций следования (их может быть несколько). Это компактный способ описания перечислимых, возможно, бесконечных множеств, позволяющий строить структурно-рекурсивные функции для обработки любых элементов этих множеств.

Как уже говорилось, в \Scheme множества, к которым принадлежат величины, определяются типом величины. Таким образом, необходимо иметь возможность определения типа, соответствующего индуктивному множеству --- \index{тип!рекурсивный}\emph{рекурсивному типу}. Для этого естественно использовать рекурсию.

Вот как можно определить тип для списка:

\begin{SchemeCode}
(define-type List
  '()
  (cons: Any List))
\end{SchemeCode}

\begin{example}{Удостоверимся, что данное нами определение работает.}
\REPL{(is '(1 2 3) List)}{#t}
\REPL{(is '(1 . 3) List)}{#f}
\end{example}

Типы могут иметь параметры, в таком случае они называются \index{тип!параметризованный}\emph{параметризованными}. Приведём пример параметризованного типа для списка величин, имеющих заданный тип $A$.

\begin{SchemeCode}[emph={A}]
(define-type (Listof A)
  '()
  (cons: A (Listof A)))
\end{SchemeCode}


\begin{example}{Так можно определить, например, типы для списка целых чисел, или списка списков.}
\REPL{(is '(1 2 3) (Listof Int))}{#t}
\begin{ExampleCode}
> (is '((1) (1 2))
      (Listof (Listof Int)))
\end{ExampleCode}
\REPLout{#t}
\end{example}

\newpage
\begin{Assignment}
а) Определите рекурсивно тип для чисел, являющихся степенями двойки. Обобщите его для степеней любых натуральных чисел. Приведите нерекурсивное определение для этих типов.
\medskip

б) С помощью функции \s{accumulate} (см.~\Asref[б]{accumulate}), напишите функцию \fun{table}{f a b}, возвращающую список значений произвольной функции \lex{f} в~целых числах от~\lex{a} до~\lex{b}.

\begin{Specification}
(test 
  (table sqr 1 3)    ==> '(1 4 9)
  (table (+ 1) 0 3)  ==> '(1 2 3 4)
  (table list -1 1)  ==> '((-1) (0) (1))
  (table sqr 3 1)    ==> '())
\end{Specification}

Выразите через неё функцию \fun{range}{a b} возвращающую список целых чисел от \lex{a} до \lex{b}.
\begin{Specification}
(test 
  (range 1 4)   ==> '(1 2 3 4)
  (range -1 1)  ==> '(-1 0 1)
  (range 3 3)   ==> '(3)
  (range 3 1)   ==> '())
\end{Specification}
% \vspace{-\bigskipamount}
\end{Assignment}

\section{Вариадические функции}%
Рассматривая синтаксис языка \Scheme, мы упоминали, что все составные выражения имеют голову, играющую роль имени функции, и~хвост~--- список аргументов функции. Так как все выражения \Scheme составляются из~точечных пар, голова выражения (имя функции) --- это \s{car} выражения, а~список аргументов~--- его \s{cdr}.

На этом основан синтаксис определения функций, которые могут принимать произвольное (потенциально неограниченное) число аргументов, таких, как функции \s{+} или \s{-}. Такие функции будем называть вариадическими.

\begin{example}{%
В этом примере мы определили простейшую функцию, возвращающую список переданных ей аргументов. Можно заметить, что по~своему поведению данная функция не~отличима от~конструктора списка \s{list}.}

\REPLin
  {(define (f . x) x)}
\REPL
  {(f 1 2 3 4)}
  {(1 2 3 4)}
\REPL
  {(f 1)}
  {(1)}
\REPL
  {(f)}
  {()}
\end{example}
\vspace{-\bigskipamount}
\begin{example}{%
Так определяется функция, принимающая один и более аргументов. При этом символ \lex{y} связывается со списком аргументов. Если передан только один аргумент -- этот список будет пустым.}

\begin{ExampleCode}[emph={x,y}]
> (define (f x . y)
    (list x y))
\end{ExampleCode}
\REPL
  {(f 1 2 3)}
  {(1 (2 3))}
\REPL
  {(f 1)}
  {(1 ())}
\end{example}

Анонимная вариадическая функция определяется таким образом:
\begin{SchemeCode}[emph={x}]
        (lambda x body) %\rmfamily или подстановкой% (/. x ___ --> body)
\end{SchemeCode}
\noindent при~этом \lex{x}~--- это список аргументов, переданных функции.

\begin{example}{%
Так с~помощью \lmфункции можно определить функцию \s{list}.}
\REPLin
  {(define list (lambda x x))}
\REPL
  {(list 1 2 3)}
  {(1 2 3 4)}
\REPL
  {(list 1)}
  {(1)}
\REPL
  {(list)}
  {()}
\end{example}

\label{variadic-rewrite}Часть аргументов определяемой функции может быть обязательной. Форма \s{(lambda (x y . z) body)} определяют функцию, принимающую два и более аргументов. Соответствующая ей подстановка записывается так: \s{(/. x y z ___ --> body)}

В определениях вариадических функций последовательность аргументов представляется в виде списка. Часто бывает необходимо применить к этим аргументам какую-либо функцию. Это можно сделать с помощью функции \s{apply}.

\begin{example}{%
Функция \fun{apply}{f arg-list} передаёт функции \lex{f} аргументы, перечисленные в списке \lex{arg-list}.}
\REPL
  {(apply cons '(1 2))}
  {(1 . 2)}
\begin{SchemeCode}
> (define (f x . y)
    (list x (apply + y)))
\end{SchemeCode}
\REPL{(f 1 2 3)}{'(1 5)}
\end{example}

Эта функция полезна в тех случаях, когда заранее неизвестно количество аргументов, передаваемых функции. Подробнее о ней мы поговорим на Занятии~\ref{Less:high-order}.

\begin{Assignment}
а) Напишите сигнатуру и определение для функции \fun{map}{f lst}, возвращающей список из~результатов применения функции \lex{f} к~каждому из~элементов списка \lex{lst}. Эта очень важная функция называется \index{отображение списка}\emph{отображением списка} или \emph{множества}.
\begin{Specification}
(test 
  (map sqr '(1 2 3))  ==> '(1 4 9)
  (map list '(a b c)) ==> '((a) (b) (c)))
\end{Specification}

б) Перепишите определение функции \s{map}, так, чтобы она могла работать с функциями произвольной валентности, принимая соответствующее число списков.
\begin{Specification}
(test 
  (map sqr '(1 2 3))  ==> '(1 4 9)
  (map cons '(a b) '(1 2))    ==> '((a . 1) (b . 2))
  (map + '(1 2) '(3 4) '(5 6)) ==> '(9 12)) ;$(1+3+5\ 2+4+6)$
\end{Specification}

Продумайте, как должна реагировать ваша функция на~списки неравной длины.
\end{Assignment}



\section{Списки за~пределами~\Scheme}%
\index{списочные структуры}Списочные структуры, списки или кортежи, как инструмент для работы с~динамическими и~нетипизированными массивами широко используются в~программировании. Очень многие современные языки имеют базовые средства для создания и~обработки списков или кортежей. Практически во~всех функциональных языках списки устроены так же, как в~\Scheme, в~виде однонаправленной списочной структуры.

В нефункциональных языках, таких, как \Lang{С++} или \Lang{Pascal} (\Lang{Delphi}) такие структуры реализуются на~указателях и~записях. Существуют стандартные библиотеки с~инструментарием для работы со~списками. Например, Standard Template Library для \Lang{C++} или LINQ для~\Lang{C\#}.

\begin{Queeze}

 \item Что такое «абстракция данных» и «абстрактный типы данных»?

 \item Что такое точечная пара? Какова связь между списками и~парами в~языке \Scheme?

 \item Как в~языке \Scheme определить функцию от~произвольного числа аргументов?

 \item Что такое индуктивное множество?

 \item Что такое структурная рекурсия, и какие преимущества даёт её использование?
 
 \item Что такое рекурсивный тип данных?

\end{Queeze}
\endinput