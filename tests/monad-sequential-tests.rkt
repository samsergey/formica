#lang racket/base
(require "../monad.rkt"
         "../formal.rkt"
         "../rewrite.rkt"
         "../tools.rkt"
         "../types.rkt"
         rackunit
         racket/sequence)

(test-case
 "zip tests"
 (check-equal? (zip '(a b c) '(1 2 3)) '((a 1) (b 2) (c 3)))
 (check-equal? (zip '(a b c) '(1 2)) '((a 1) (b 2)))
 (check-equal? (zip '(a b) '(1 2 3)) '((a 1) (b 2)))
 (check-equal? (sequence->list (zip '(a b) 3)) '((a 0) (b 1))))

(test-case
 "listable? tests"
 (check-false (listable? 3))
 (check-false (listable? 0)) 
 (check-true (listable? "abc")) 
 (check-true (listable? (in-range 3)))
 (check-true (listable? (in-naturals)))
 (check-true (listable? '(a b c)))
 (check-true (listable? (set 'a 'b 'c)))
 (check-true (listable? (stream 'a 'b 'c)))
 (check-true (listable? '(g x)))
 
 (check-false (listable? -1))
 (check-false (listable? 'x))
 (define-formal f)
 (check-false (listable? (f 'x)))
 (check-false (listable? (f 'x 'y))))

(test-case
 "Monad List"
 (using-monad List)
 (define-formal f g)
 (define (F x) (return (f 1 x) (f 2 x)))
 (define (G x) (return (g 1 x) (g 2 x)))
 (define (Z x) mzero)
 ; the basic monadic functions
 (check-equal? (return 'x) (list 'x))
 (check-equal? (return 'x 'y 'x) (list 'x 'y 'x))
 (check-equal? mzero null)
 (check-equal? (mplus '(1 2) '(2 3)) '(1 2 2 3))
 ; the monad laws
 (check-equal? (bind (return 'x) >>= (lift f)) (return (f 'x)))
 (check-equal? (bind (return 'x) >>= F) (return (f 1 'x) (f 2 'x)))
 (check-equal? (bind (return 'x 'y 'z) >>= (lift f)) (return (f 'x) (f 'y) (f 'z)))
 (check-equal? (bind (return 'x 'y 'z) >>= F) 
                      (return (f 1 'x) (f 2 'x) (f 1 'y) (f 2 'y) (f 1 'z) (f 2 'z)))
 (check-equal? (bind (return 'x) >>= return) (return 'x))
 (check-equal? (bind (return 'x 'y 'z) >>= return) (return 'x 'y 'z))
 (check-equal? (bind (bind (return 'x) >>= (lift f)) >>= (lift g)) 
                      (bind (return 'x) >>= (λ (x) (bind (return (f x)) >>= (lift g)))))
 (check-equal? (bind (bind (return 'x 'y) >>= (lift f)) >>= (lift g)) 
                      (bind (return 'x 'y) >>= (λ (x) (bind (return (f x)) >>= (lift g)))))
 (check-equal? (bind (bind (return 'x) >>= F) >>= G) 
                      (bind (return 'x) >>= (λ (x) (bind (F x) >>= G))))
 (check-equal? (bind (bind (return 'x 'y) >>= F) >>= G) 
                      (bind (return 'x 'y) >>= (λ (x) (bind (F x) >>= G))))
 ;the additive monad laws
 (check-equal? (bind mzero >>= (lift f)) mzero)
 (check-equal? (bind mzero >>= F) mzero)
 (check-equal? (bind (return 'x) >>= (λ (_) mzero)) mzero)
 (check-equal? (bind (return 'x 'y) >>= (λ (_) mzero)) mzero)
 (check-equal? (mplus mzero (return 'x)) (return 'x))
 (check-equal? (mplus mzero (return 'x 'y)) (return 'x 'y))
 (check-equal? (mplus (return 'x) mzero) (return 'x))
 (check-equal? (mplus (return 'x 'y) mzero) (return 'x 'y))
 ; guarding
 (check-equal? (bind (return 'x) >>= (guardf (const #t)) >>= (lift g)) (return (g 'x)))
 (check-equal? (bind (return 'x 'y) >>= (guardf (const #t)) >>= (lift g)) (return (g 'x) (g 'y)))
 (check-equal? (bind (return 'x) >>= (guardf (const #t)) >>= G) (return (g 1 'x) (g 2 'x)))
 (check-equal? (bind (return 'x 'y) >>= (guardf (const #t)) >>= G) (return (g 1 'x) (g 2 'x) (g 1 'y) (g 2 'y)))
 (check-equal? (bind (return 'x) >>= (guardf (const #f)) >>= (lift g)) mzero)
 (check-equal? (bind (return 'x 'y) >>= (guardf (const #f)) >>= (lift g)) mzero)
 (check-equal? (bind (return 'x) >>= (guardf (const #f)) >>= G) mzero)
 (check-equal? (bind (return 'x 'y) >>= (guardf (const #f)) >>= G) mzero)
 (check-equal? (do [x <-: 'x] (guard #t) (return (g x))) (return (g 'x)))
 (check-equal? (do [x <- (return 'x 'y)] (guard #t) (return (g x))) (return (g 'x) (g 'y)))
 (check-equal? (do [x <-: 'x] (guard #t) (G x)) (return (g 1 'x) (g 2 'x)))
 (check-equal? (do [x <- (return 'x 'y)] (guard #t) (G x)) (return (g 1 'x) (g 2 'x) (g 1 'y) (g 2 'y)))
 ; monadic composition
 (check-equal? ((compose/m (lift f) (lift g)) 'x) (return (f (g 'x))))
 (check-equal? ((compose/m (lift f) (lift g)) 'x 'y) (return (f (g 'x)) (f (g 'y))))
 (check-equal? ((compose/m F (lift g)) 'x) (return (f 1 (g 'x)) (f 2 (g 'x))))
 (check-equal? ((compose/m (lift f) G) 'x) (return (f (g 1 'x)) (f (g 2 'x))))
 (check-equal? ((compose/m F G) 'x) (return (f 1 (g 1 'x)) (f 2 (g 1 'x)) (f 1 (g 2 'x)) (f 2 (g 2 'x))))
 (check-equal? ((compose/m F G) 'x) (return (f 1 (g 1 'x)) (f 2 (g 1 'x)) (f 1 (g 2 'x)) (f 2 (g 2 'x))))
 (check-equal? ((compose/m Z G) 'x) mzero)
 (check-equal? ((compose/m F Z) 'x) mzero)
 ; monadic lifting
 (check-equal? (lift/m f (return 'x)) (return (f 'x)))
 (check-equal? (lift/m f (return 'x 'y)) (return (f 'x) (f 'y)))
 (check-equal? (lift/m f (return 'x) (return 'y)) (return (f 'x 'y)))
 (check-equal? (lift/m f (return 'x 'y) (return 'z)) (return (f 'x 'z) (f 'y 'z)))
 (check-equal? (lift/m f (return 'x 'y) mzero) mzero)
 (check-equal? (lift/m f (return 'x 'y) mzero (return 'z)) mzero)
 ;monadic folding
 (check-equal? (fold/m (lift f) 'x '(a b c)) (return (f 'c (f 'b (f 'a 'x)))))
 (check-equal? (fold/m (λ (x y) (return (f x y) (g x y))) 'x '(a b c)) 
                      (return (f 'c (f 'b (f 'a 'x))) 
                              (g 'c (f 'b (f 'a 'x))) 
                              (f 'c (g 'b (f 'a 'x))) 
                              (g 'c (g 'b (f 'a 'x))) 
                              (f 'c (f 'b (g 'a 'x))) 
                              (g 'c (f 'b (g 'a 'x))) 
                              (f 'c (g 'b (g 'a 'x))) 
                              (g 'c (g 'b (g 'a 'x)))))
 ; monadic filtering
 (check-equal? (filter/m (lift (const #t)) '(a b c)) (return '(a b c)))
 (check-equal? (filter/m (lift (const #f)) '(a b c)) (return '()))
 (check-equal? (filter/m (lift (/. 'b --> #f)) '(a b c d)) (return '(a c d)))
 (check-equal? (filter/m (lift odd?) '(1 2 3 4 5)) (return '(1 3 5)))
 (check-equal? (filter/m (lift odd?) '(1 2 3 4 5 6)) (return '(1 3 5)))
 (check-equal? (filter/m (λ (x) (return #t #f)) '(1 2 3)) (return '(1 2 3) '(1 2) '(1 3) '(1) '(2 3) '(2) '(3) '()))
 ; monadic mapping
 (check-equal? (map/m (lift f) '(a b c)) (return '((f a) (f b) (f c))))
 (check-equal? (map/m F '(a b)) (return '((f 1 a) (f 1 b)) '((f 1 a) (f 2 b)) '((f 2 a) (f 1 b)) '((f 2 a) (f 2 b))))
 ; monadic sequencing
 (check-equal? (sequence/m (list (return 'a) (return 'b) (return 'c))) (return '(a b c)))
 (check-equal? (sequence/m (list (return 'a 'b) (return 'c) (return 'd 'e))) (return '(a c d) '(a c e) '(b c d) '(b c e)))
 (check-equal? (sequence/m (list (return 'a) mzero (return 'c))) mzero)
 (check-equal? (sequence/m (list (return 'a 'b) mzero (return 'c))) mzero)
 ; monadic sum
 (check-equal? (sum/m (list (return 'a) (return 'b) (return 'c))) (return 'a 'b 'c))
 (check-equal? (sum/m (list (return 'a 'b) (return 'c) (return 'd 'e))) (return 'a 'b 'c 'd 'e))
 (check-equal? (sum/m (list (return 'a 'b) mzero (return 'd 'e))) (return 'a 'b 'd 'e))
 ; failure
 (check-equal? (do [1 <- '(1 2 3 2 1 2 3)] (return 'y)) (return 'y 'y))
 (check-equal? (collect x [(? odd? x) <- '(1 2 3 2 1 2 3)]) (return 1 3 1 3))
 (check-equal? (collect x [(? odd? x) <- (range 5)]) (return 1 3))
 ; zipping
 #;(check-equal? (collect (cons x y) [(list x y) <- 
                                               (stream->list (zip '(a b c) (in-naturals)))])
                      (return '(a . 0) '(b . 1) '(c . 2)))
  ; type checking
 (check-exn exn:fail:contract? (λ () (bind 'x >>= (lift f))))
 (check-exn exn:fail:contract? (λ () (bind 'x >>= f)))
 (check-exn exn:fail:contract? (λ () (stream-first ((compose/m f (lift g)) 'x))))
 (check-exn exn:fail:contract? (λ () (stream-first ((compose/m (lift f) g) 'x))))
 (check-exn exn:fail:contract? (λ () (lift/m f 'x)))
 (check-exn exn:fail:contract? (λ () (fold/m f 'x '(a b c))))
 (check-exn exn:fail:contract? (λ () (map/m f '(a b c))))
 (check-exn exn:fail:contract? (λ () (sequence/m (list (return 'x) 'y))))
 (check-exn exn:fail:contract? (λ () (sum/m (list (return 'x) 'y)))))

#;(require "../examples/nondeterministic.rkt")


(define-syntax-rule (check-stream-equal? s1 s2)
  (check-equal? (stream->list s1) (stream->list s2)))

(test-case
 "Monad Stream"
 (using-monad Stream)
 (define-formal f g)
 (define (F x) (return (f 1 x) (f 2 x)))
 (define (G x) (return (g 1 x) (g 2 x)))
 (define (Z x) mzero)
 ; the basic monadic functions
 (check-stream-equal? (return 'x) (stream 'x))
 (check-stream-equal? mzero (stream))
 (check-stream-equal? (mplus (stream 1 2) (stream 3 4)) (stream 1 2 3 4))
 ; the monad laws
 (check-stream-equal? (bind (return 'x) >>= (lift f)) (return (f 'x)))
 (check-stream-equal? (bind (return 'x) >>= F) (return (f 1 'x) (f 2 'x)))
 (check-stream-equal? (bind (return 'x 'y 'z) >>= (lift f)) (return (f 'x) (f 'y) (f 'z)))
 (check-stream-equal? (bind (return 'x 'y 'z) >>= F) 
                     (stream (f 1 'x) (f 2 'x) (f 1 'y) (f 2 'y) (f 1 'z) (f 2 'z)))
 (check-stream-equal? (bind (return 'x) >>= return) (return 'x))
 (check-stream-equal? (bind (return 'x 'y 'z) >>= return) (return 'x 'y 'z))
 (check-stream-equal? (bind (bind (return 'x) >>= (lift f)) >>= (lift g)) 
                      (bind (return 'x) >>= (λ (x) (bind (return (f x)) >>= (lift g)))))
 (check-stream-equal? (bind (bind (return 'x 'y) >>= (lift f)) >>= (lift g)) 
                      (bind (return 'x 'y) >>= (λ (x) (bind (return (f x)) >>= (lift g)))))
 (check-stream-equal? (bind (bind (return 'x) >>= F) >>= G) 
                      (bind (return 'x) >>= (λ (x) (bind (F x) >>= G))))
 (check-stream-equal? (bind (bind (return 'x 'y) >>= F) >>= G) 
                      (bind (return 'x 'y) >>= (λ (x) (bind (F x) >>= G))))
 ;the additive monad laws
 (check-stream-equal? (bind mzero >>= (lift f)) mzero)
 (check-stream-equal? (bind mzero >>= F) mzero)
 (check-stream-equal? (bind (return 'x) >>= (λ (_) mzero)) mzero)
 (check-stream-equal? (bind (return 'x 'y) >>= (λ (_) mzero)) mzero)
 (check-stream-equal? (mplus mzero (return 'x)) (return 'x))
 (check-stream-equal? (mplus mzero (return 'x 'y)) (return 'x 'y))
 (check-stream-equal? (mplus (return 'x) mzero) (return 'x))
 (check-stream-equal? (mplus (return 'x 'y) mzero) (return 'x 'y))
 ; guarding
 (check-stream-equal? (bind (return 'x) >>= (guardf (const #t)) >>= (lift g)) (return (g 'x)))
 (check-stream-equal? (bind (return 'x 'y) >>= (guardf (const #t)) >>= (lift g)) (return (g 'x) (g 'y)))
 (check-stream-equal? (bind (return 'x) >>= (guardf (const #t)) >>= G) (return (g 1 'x) (g 2 'x)))
 (check-stream-equal? (bind (return 'x 'y) >>= (guardf (const #t)) >>= G) (return (g 1 'x) (g 2 'x) (g 1 'y) (g 2 'y)))
 (check-stream-equal? (bind (return 'x) >>= (guardf (const #f)) >>= (lift g)) mzero)
 (check-stream-equal? (bind (return 'x 'y) >>= (guardf (const #f)) >>= (lift g)) mzero)
 (check-stream-equal? (bind (return 'x) >>= (guardf (const #f)) >>= G) mzero)
 (check-stream-equal? (bind (return 'x 'y) >>= (guardf (const #f)) >>= G) mzero)
 (check-stream-equal? (do [x <-: 'x] (guard #t) (return (g x))) (return (g 'x)))
 (check-stream-equal? (do [x <- (return 'x 'y)] (guard #t) (return (g x))) (return (g 'x) (g 'y)))
 (check-stream-equal? (do [x <-: 'x] (guard #t) (G x)) (return (g 1 'x) (g 2 'x)))
 (check-stream-equal? (do [x <- (return 'x 'y)] (guard #t) (G x)) (return (g 1 'x) (g 2 'x) (g 1 'y) (g 2 'y)))
 ; monadic composition
 (check-stream-equal? ((compose/m (lift f) (lift g)) 'x) (return (f (g 'x))))
 (check-stream-equal? ((compose/m (lift f) (lift g)) 'x 'y) (return (f (g 'x)) (f (g 'y))))
 (check-stream-equal? ((compose/m F (lift g)) 'x) (return (f 1 (g 'x)) (f 2 (g 'x))))
 (check-stream-equal? ((compose/m (lift f) G) 'x) (return (f (g 1 'x)) (f (g 2 'x))))
 (check-stream-equal? ((compose/m F G) 'x) (return (f 1 (g 1 'x)) (f 2 (g 1 'x)) (f 1 (g 2 'x)) (f 2 (g 2 'x))))
 (check-stream-equal? ((compose/m F G) 'x) (return (f 1 (g 1 'x)) (f 2 (g 1 'x)) (f 1 (g 2 'x)) (f 2 (g 2 'x))))
 (check-stream-equal? ((compose/m Z G) 'x) mzero)
 (check-stream-equal? ((compose/m F Z) 'x) mzero)
 ; monadic lifting
 (check-stream-equal? (lift/m f (return 'x)) (return (f 'x)))
 (check-stream-equal? (lift/m f (return 'x 'y)) (return (f 'x) (f 'y)))
 (check-stream-equal? (lift/m f (return 'x) (return 'y)) (return (f 'x 'y)))
 (check-stream-equal? (lift/m f (return 'x 'y) (return 'z)) (return (f 'x 'z) (f 'y 'z)))
 (check-stream-equal? (lift/m f (return 'x 'y) mzero) mzero)
 (check-stream-equal? (lift/m f (return 'x 'y) mzero (return 'z)) mzero)
 ;monadic folding
 (check-stream-equal? (fold/m (lift f) 'x '(a b c)) (return (f 'c (f 'b (f 'a 'x)))))
 (check-stream-equal? (fold/m (λ (x y) (return (f x y) (g x y))) 'x '(a b c)) 
                      (return (f 'c (f 'b (f 'a 'x))) 
                              (g 'c (f 'b (f 'a 'x))) 
                              (f 'c (g 'b (f 'a 'x))) 
                              (g 'c (g 'b (f 'a 'x))) 
                              (f 'c (f 'b (g 'a 'x))) 
                              (g 'c (f 'b (g 'a 'x))) 
                              (f 'c (g 'b (g 'a 'x))) 
                              (g 'c (g 'b (g 'a 'x)))))
 ; monadic filtering
 (check-stream-equal? (filter/m (lift (const #t)) '(a b c)) (return '(a b c)))
 (check-stream-equal? (filter/m (lift (const #f)) '(a b c)) (return '()))
 (check-stream-equal? (filter/m (lift (/. 'b --> #f)) '(a b c d)) (return '(a c d)))
 (check-stream-equal? (filter/m (lift odd?) '(1 2 3 4 5)) (return '(1 3 5)))
 (check-stream-equal? (filter/m (lift odd?) '(1 2 3 4 5 6)) (return '(1 3 5)))
 (check-stream-equal? (filter/m (λ (x) (return #t #f)) '(1 2 3)) (return '(1 2 3) '(1 2) '(1 3) '(1) '(2 3) '(2) '(3) '()))
 ; monadic mapping
 (check-stream-equal? (map/m (lift f) '(a b c)) (return '((f a) (f b) (f c))))
 (check-stream-equal? (map/m F '(a b)) (return '((f 1 a) (f 1 b)) '((f 1 a) (f 2 b)) '((f 2 a) (f 1 b)) '((f 2 a) (f 2 b))))
 ; monadic sequencing
 (check-stream-equal? (sequence/m (list (return 'a) (return 'b) (return 'c))) (return '(a b c)))
 (check-stream-equal? (sequence/m (list (return 'a 'b) (return 'c) (return 'd 'e))) (return '(a c d) '(a c e) '(b c d) '(b c e)))
 (check-stream-equal? (sequence/m (list (return 'a) mzero (return 'c))) mzero)
 (check-stream-equal? (sequence/m (list (return 'a 'b) mzero (return 'c))) mzero)
 ; monadic sum
 (check-stream-equal? (sum/m (list (return 'a) (return 'b) (return 'c))) (return 'a 'b 'c))
 (check-stream-equal? (sum/m (list (return 'a 'b) (return 'c) (return 'd 'e))) (return 'a 'b 'c 'd 'e))
 (check-stream-equal? (sum/m (list (return 'a 'b) mzero (return 'd 'e))) (return 'a 'b 'd 'e))
 ; failure
 (check-stream-equal? (do [1 <- (in-list '(1 2 3 2 1 2 3))] (return 'y)) (return 'y 'y))
 (check-stream-equal? (collect x [(? odd? x) <- (return 1 2 3 2 1 2 3)]) (return 1 3 1 3))
 (check-stream-equal? (collect x [(? odd? x) <- (in-range 5)]) (return 1 3))
 ; zipping
 #;(check-stream-equal? (collect (cons x y) [(list x y) <- (zip '(a b c) (in-naturals))])
                      (return '(a . 0) '(b . 1) '(c . 2)))
  ; type checking
 (check-exn exn:fail:contract? (λ () (bind 'x >>= (lift f))))
 (check-exn exn:fail:contract? (λ () (bind 'x >>= f)))
 (check-exn exn:fail:contract? (λ () (stream-first ((compose/m f (lift g)) 'x))))
 (check-exn exn:fail:contract? (λ () (stream-first ((compose/m (lift f) g) 'x))))
 (check-exn exn:fail:contract? (λ () (lift/m f 'x)))
 (check-exn exn:fail:contract? (λ () (fold/m f 'x '(a b c))))
 (check-exn exn:fail:contract? (λ () (map/m f '(a b c))))
 (check-exn exn:fail:contract? (λ () (stream-first (sequence/m (list (return 'x) 'y)))))
 (check-exn exn:fail:contract? (λ () (stream->list (sum/m (list (return 'x) 'y)))))

 ;  lazyness
 (check-equal? (stream-ref (bind (return 1 0 2) >>= (lift /)) 0) 1)
 (check-exn exn:fail? (λ () (stream-ref (bind (return 1 0 2) >>= (lift /)) 1)))
 (check-equal? (stream-ref (bind (return 1 0 2) >>= (lift /) >>= (lift g)) 0) (g 1))
 (check-equal? (stream-first ((compose/m (lift /) (lift (curry * 2))) 1 0)) 1/2)
 (check-exn exn:fail? (λ () (stream-ref ((compose/m (lift /) (lift (curry * 2))) 1 0) 1)))
 (check-equal? (stream-first (lift/m / (return 1) (return 1 0))) 1)
 (check-exn exn:fail? (λ () (stream-ref (lift/m / (return 1) (return 1 0)) 1)))
 (check-equal? (stream-first (sequence/m (list (return 1) (stream 0 (/ 0))))) '(1 0))
 (check-exn exn:fail? (λ () (stream-ref (sequence/m (list (return 1) (stream 0 (/ 0)))) 1)))
 (check-equal? (stream-ref (bind (stream 1 0 2) >>= (lift /)) 0) 1)
 (check-exn exn:fail? (λ () (stream-ref (bind (stream 1 0 2) >>= (lift /)) 1)))
 (check-equal? (stream-ref (bind (stream 1 0 2) >>= (lift /) >>= (lift g)) 0) (g 1))
 (check-equal? (stream-first ((compose/m (lift log) (lift (curry + 1))) 0 -1)) 0)
 (check-exn exn:fail? (λ () (stream-ref ((compose/m (lift log) (lift (curry + 1))) 0 -1) 1)))
 (check-equal? (stream-first (lift/m / (stream 1) (stream 1 0))) 1)
 (check-exn exn:fail? (λ () (stream-ref (lift/m / (stream 1) (stream 1 0)) 1)))
 (check-equal? (stream-first (sequence/m (list (stream 1) (stream 0 (/ 0))))) '(1 0))
 (check-exn exn:fail? (λ () (stream-ref (sequence/m (list (stream 1) (stream 0 (/ 0)))) 1)))
 (check-equal? (stream-ref (map/m (λ (x) (stream x (/ x))) '(1 0 3)) 0) '(1 0 3))
 (check-equal? (stream-ref (map/m (λ (x) (stream x (/ x))) '(1 0 3)) 1) '(1 0 1/3))
 (check-exn exn:fail? (λ () (stream-ref (map/m (λ (x) (stream x (/ x))) '(1 0 3)) 2)))
 (check-equal? (stream-first (filter/m (λ (x) (stream x (/ x))) '(1 0 3))) '(1 0 3))
 (check-exn exn:fail? (λ () (stream-ref (filter/m (λ (x) (stream x (/ x))) '(1 0 3)) 2)))
 (check-equal? (stream-first (fold/m (λ (x y) (stream (+ x y) (+ (/ x) y))) 1 '(1 0 2))) 4)
 (check-equal? (stream-ref (fold/m (λ (x y) (stream (+ x y) (+ (/ x) y))) 1 '(1 0 2)) 1) 5/2)
 (check-exn exn:fail? (λ () (stream-ref (fold/m (λ (x y) (stream (+ x y) (+ (/ x) y))) 1 '(1 0 2)) 2)))
 ; using eager function return instead of lazy form stream as constructor destroys lazyness.
 (check-exn exn:fail? (λ () (stream-first (map/m (λ (x) (return x (/ x))) '(1 2 0 3)))))
 (check-exn exn:fail? (λ () (stream-first (filter/m (λ (x) (return x (/ x))) '(1 0 3)))))
 (check-exn exn:fail? (λ () (stream-first (fold/m (λ (x y) (return (f x y) (f (/ x) y))) 1 (return 1 0 2)))))
 )

(define-syntax-rule (check-stream-equal?* s1 s2)
  (check-equal? (sort (stream->list s1) ordered?) 
                (sort (stream->list s2) ordered?)))

#;(test-case
 "Monad Amb"
 (using-monad Amb)
 (define-formal f g)
 (define (F x) (return (f 1 x) (f 2 x)))
 (define (G x) (return (g 1 x) (g 2 x)))
 (define (Z x) mzero)
 ; the basic monadic functions
 (check-stream-equal?* (return 'x) (stream 'x))
 (check-stream-equal?* (return 'x 'y) (stream 'x 'y))
 (check-stream-equal?* (return 'x 'y 'z) (stream 'x 'y 'z))
 (check-stream-equal?* (return 'x 'y 'x) (stream 'x 'y))
 (check-stream-equal?* mzero (stream))
 (check-stream-equal?* (mplus (stream 1 2) (stream 2 3)) (stream 1 2 3))
 ; the monad laws
 (check-stream-equal?* (bind (return 'x) >>= (lift f)) (return (f 'x)))
 (check-stream-equal?* (bind (return 'x) >>= F) (return (f 1 'x) (f 2 'x)))
 (check-stream-equal?* (bind (return 'x 'y 'z) >>= (lift f)) (return (f 'x) (f 'y) (f 'z)))
 (check-stream-equal?* (bind (return 'x 'y 'z) >>= F) 
                      (stream (f 1 'x) (f 2 'x) (f 1 'y) (f 2 'y) (f 1 'z) (f 2 'z)))
 (check-stream-equal?* (bind (return 'x) >>= return) (return 'x))
 (check-stream-equal?* (bind (return 'x 'y 'z) >>= return) (return 'x 'y 'z))
 (check-stream-equal?* (bind (bind (return 'x) >>= (lift f)) >>= (lift g)) 
                      (bind (return 'x) >>= (λ (x) (bind (return (f x)) >>= (lift g)))))
 (check-stream-equal?* (bind (bind (return 'x 'y) >>= (lift f)) >>= (lift g)) 
                      (bind (return 'x 'y) >>= (λ (x) (bind (return (f x)) >>= (lift g)))))
 (check-stream-equal?* (bind (bind (return 'x) >>= F) >>= G) 
                      (bind (return 'x) >>= (λ (x) (bind (F x) >>= G))))
 (check-stream-equal?* (bind (bind (return 'x 'y) >>= F) >>= G) 
                      (bind (return 'x 'y) >>= (λ (x) (bind (F x) >>= G))))
 ;the additive monad laws
 (check-stream-equal?* (bind mzero >>= (lift f)) mzero)
 (check-stream-equal?* (bind mzero >>= F) mzero)
 (check-stream-equal?* (bind (return 'x) >>= (λ (_) mzero)) mzero)
 (check-stream-equal?* (bind (return 'x 'y) >>= (λ (_) mzero)) mzero)
 (check-stream-equal?* (mplus mzero (return 'x)) (return 'x))
 (check-stream-equal?* (mplus mzero (return 'x 'y)) (return 'x 'y))
 (check-stream-equal?* (mplus (return 'x) mzero) (return 'x))
 (check-stream-equal?* (mplus (return 'x 'y) mzero) (return 'x 'y))
 ; guarding
 (check-stream-equal?* (bind (return 'x) >>= (guardf (const #t)) >>= (lift g)) (return (g 'x)))
 (check-stream-equal?* (bind (return 'x 'y) >>= (guardf (const #t)) >>= (lift g)) (return (g 'x) (g 'y)))
 (check-stream-equal?* (bind (return 'x) >>= (guardf (const #t)) >>= G) (return (g 1 'x) (g 2 'x)))
 (check-stream-equal?* (bind (return 'x 'y) >>= (guardf (const #t)) >>= G) (return (g 1 'x) (g 2 'x) (g 1 'y) (g 2 'y)))
 (check-stream-equal?* (bind (return 'x) >>= (guardf (const #f)) >>= (lift g)) mzero)
 (check-stream-equal?* (bind (return 'x 'y) >>= (guardf (const #f)) >>= (lift g)) mzero)
 (check-stream-equal?* (bind (return 'x) >>= (guardf (const #f)) >>= G) mzero)
 (check-stream-equal?* (bind (return 'x 'y) >>= (guardf (const #f)) >>= G) mzero)
 (check-stream-equal?* (do [x <-: 'x] (guard #t) (return (g x))) (return (g 'x)))
 (check-stream-equal?* (do [x <- (return 'x 'y)] (guard #t) (return (g x))) (return (g 'x) (g 'y)))
 (check-stream-equal?* (do [x <-: 'x] (guard #t) (G x)) (return (g 1 'x) (g 2 'x)))
 (check-stream-equal?* (do [x <- (return 'x 'y)] (guard #t) (G x)) (return (g 1 'x) (g 2 'x) (g 1 'y) (g 2 'y)))
 ; monadic composition
 (check-stream-equal?* ((compose/m (lift f) (lift g)) 'x) (return (f (g 'x))))
 (check-stream-equal?* ((compose/m (lift f) (lift g)) 'x 'y) (return (f (g 'x)) (f (g 'y))))
 (check-stream-equal?* ((compose/m F (lift g)) 'x) (return (f 1 (g 'x)) (f 2 (g 'x))))
 (check-stream-equal?* ((compose/m (lift f) G) 'x) (return (f (g 1 'x)) (f (g 2 'x))))
 (check-stream-equal?* ((compose/m F G) 'x) (return (f 1 (g 1 'x)) (f 2 (g 1 'x)) (f 1 (g 2 'x)) (f 2 (g 2 'x))))
 (check-stream-equal?* ((compose/m F G) 'x) (return (f 1 (g 1 'x)) (f 2 (g 1 'x)) (f 1 (g 2 'x)) (f 2 (g 2 'x))))
 (check-stream-equal?* ((compose/m Z G) 'x) mzero)
 (check-stream-equal?* ((compose/m F Z) 'x) mzero)
 ; monadic lifting
 (check-stream-equal?* (lift/m f (return 'x)) (return (f 'x)))
 (check-stream-equal?* (lift/m f (return 'x 'y)) (return (f 'x) (f 'y)))
 (check-stream-equal?* (lift/m f (return 'x) (return 'y)) (return (f 'x 'y)))
 (check-stream-equal?* (lift/m f (return 'x 'y) (return 'z)) (return (f 'x 'z) (f 'y 'z)))
 (check-stream-equal?* (lift/m f (return 'x 'y) mzero) mzero)
 (check-stream-equal?* (lift/m f (return 'x 'y) mzero (return 'z)) mzero)
 ;monadic folding
 (check-stream-equal?* (fold/m (lift f) 'x '(a b c)) (return (f 'c (f 'b (f 'a 'x)))))
 (check-stream-equal?* (fold/m (λ (x y) (return (f x y) (g x y))) 'x '(a b c)) 
                      (return (f 'c (f 'b (f 'a 'x))) 
                              (g 'c (f 'b (f 'a 'x))) 
                              (f 'c (g 'b (f 'a 'x))) 
                              (g 'c (g 'b (f 'a 'x))) 
                              (f 'c (f 'b (g 'a 'x))) 
                              (g 'c (f 'b (g 'a 'x))) 
                              (f 'c (g 'b (g 'a 'x))) 
                              (g 'c (g 'b (g 'a 'x)))))
 ; monadic filtering
 (check-stream-equal?* (filter/m (lift (const #t)) '(a b c)) (return '(a b c)))
 (check-stream-equal?* (filter/m (lift (const #f)) '(a b c)) (return '()))
 (check-stream-equal?* (filter/m (lift (/. 'b --> #f)) '(a b c d)) (return '(a c d)))
 (check-stream-equal?* (filter/m (lift odd?) '(1 2 3 4 5)) (return '(1 3 5)))
 (check-stream-equal?* (filter/m (lift odd?) '(1 2 3 4 5 6)) (return '(1 3 5)))
 (check-stream-equal?* (filter/m (λ (x) (return #t #f)) '(1 2 3)) (return '(1 2 3) '(1 2) '(1 3) '(1) '(2 3) '(2) '(3) '()))
 ; monadic mapping
 (check-stream-equal?* (map/m (lift f) '(a b c)) (return '((f a) (f b) (f c))))
 (check-stream-equal?* (map/m F '(a b)) (return '((f 1 a) (f 1 b)) '((f 1 a) (f 2 b)) '((f 2 a) (f 1 b)) '((f 2 a) (f 2 b))))
 ; monadic sequencing
 (check-stream-equal?* (sequence/m (list (return 'a) (return 'b) (return 'c))) (return '(a b c)))
 (check-stream-equal?* (sequence/m (list (return 'a 'b) (return 'c) (return 'd 'e))) (return '(a c d) '(a c e) '(b c d) '(b c e)))
 (check-stream-equal?* (sequence/m (list (return 'a) mzero (return 'c))) mzero)
 (check-stream-equal?* (sequence/m (list (return 'a 'b) mzero (return 'c))) mzero)
 ; monadic sum
 (check-stream-equal?* (sum/m (list (return 'a) (return 'b) (return 'c))) (return 'a 'b 'c))
 (check-stream-equal?* (sum/m (list (return 'a 'b) (return 'c) (return 'd 'e))) (return 'a 'b 'c 'd 'e))
 (check-stream-equal?* (sum/m (list (return 'a 'b) mzero (return 'd 'e))) (return 'a 'b 'd 'e))
 ; failure
 (check-stream-equal?* (do [1 <- '(1 2 3 2 1 2 3)] (return 'y)) (return 'y 'y))
 (check-stream-equal?* (collect x [(? odd? x) <- '(1 2 3 2 1 2 3)]) (return 1 3 1 3))
 (check-stream-equal?* (collect x [(? odd? x) <- 5]) (return 1 3))
 ; zipping
 (check-stream-equal?* (collect (cons x y) [(list x y) <- (zip '(a b c) (in-naturals))])
                      (return '(a . 0) '(b . 1) '(c . 2)))
  ; type checking
 (check-exn exn:fail:contract? (λ () (bind 'x >>= (lift f))))
 (check-exn exn:fail:contract? (λ () (bind 'x >>= f)))
 (check-exn exn:fail:contract? (λ () (stream-first ((compose/m f (lift g)) 'x))))
 (check-exn exn:fail:contract? (λ () (stream-first ((compose/m (lift f) g) 'x))))
 (check-exn exn:fail:contract? (λ () (lift/m f 'x)))
 (check-exn exn:fail:contract? (λ () (fold/m f 'x '(a b c))))
 (check-exn exn:fail:contract? (λ () (map/m f '(a b c))))
 (check-exn exn:fail:contract? (λ () (stream-first (sequence/m (list (return 'x) 'y)))))
 (check-exn exn:fail:contract? (λ () (stream->list (sum/m (list (return 'x) 'y)))))

 ;  lazyness
 (check-equal? (stream-ref (bind (amb 1 0 2) >>= (lift /)) 0) 1)
 (check-exn exn:fail? (λ () (stream-ref (bind (amb 1 0 2) >>= (lift /)) 1)))
 (check-equal? (stream-ref (bind (amb 1 0 2) >>= (lift /) >>= (lift g)) 0) (g 1))
 (check-equal? (stream-first ((compose/m (lift log) (lift (curry + 1))) 0 -1)) 0)
 (check-exn exn:fail? (λ () (stream-ref ((compose/m (lift log) (lift (curry + 1))) 0 -1) 1)))
 (check-equal? (stream-first (lift/m / (amb 1) (amb 1 0))) 1)
 (check-exn exn:fail? (λ () (stream-ref (lift/m / (amb 1) (amb 1 0)) 1)))
 (check-equal? (stream-first (sequence/m (list (amb 1) (amb 0 (/ 0))))) '(1 0))
 (check-exn exn:fail? (λ () (stream-ref (sequence/m (list (amb 1) (amb 0 (/ 0)))) 1)))
 (check-equal? (stream-ref (map/m (λ (x) (amb x (/ x))) '(1 0 3)) 0) '(1 0 3))
 (check-equal? (stream-ref (map/m (λ (x) (amb x (/ x))) '(1 0 3)) 1) '(1 0 1/3))
 (check-exn exn:fail? (λ () (stream-ref (map/m (λ (x) (amb x (/ x))) '(1 0 3)) 2)))
 (check-equal? (stream-first (filter/m (λ (x) (amb x (/ x))) '(1 0 3))) '(1 0 3))
 (check-exn exn:fail? (λ () (stream-ref (filter/m (λ (x) (amb x (/ x))) '(1 0 3)) 1)))
 (check-equal? (stream-first (fold/m (λ (x y) (amb (+ x y) (+ (/ x) y))) 1 '(1 0 2))) 4)
 (check-equal? (stream-ref (fold/m (λ (x y) (amb (+ x y) (+ (/ x) y))) 1 '(1 0 2)) 1) 5/2)
 (check-exn exn:fail? (λ () (stream-ref (fold/m (λ (x y) (amb (+ x y) (+ (/ x) y))) 1 '(1 0 2)) 2)))
 )